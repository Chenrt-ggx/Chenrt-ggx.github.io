<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Chenrt"><meta name="keywords" content="Chenrt, @Chenrt, Chenrt Blog, 计算机, 网络安全, 博客, 个人网站"><meta name="description" content="Chenrt 的个人博客"><meta name="generator" content="Hexo"><link rel="icon" href="/favicon.svg"><title>Chenrt の 小窝 - 前后端分离下 Web 前端的一些经验</title><script defer="defer" src="/js/chunk-vendors.js"></script><script defer="defer" src="/js/app.js"></script><link href="/css/chunk-vendors.css" rel="stylesheet"><link href="/css/app.css" rel="stylesheet"></head><body><noscript><header><nav><a href="/">Home</a></nav><nav><a href="/blogs/1">Blogs</a></nav><nav><a href="/category">Categories</a></nav><nav><a href="/tag">Tags</a></nav><nav><a href="/archive">Archives</a></nav><nav><a href="/about">About</a></nav><nav><a href="/apis">Api</a></nav></header><div><br></div><content><div><a href="/blog/c6be5f9c8134"><h1>前后端分离下 Web 前端的一些经验</h1></a><div><div><div><a href="/category/Buaa/1">Buaa</a></div><div><a href="/category/Buaa/SE/1">SE</a></div></div></div><div><div><div><a href="/tag/Vue/1">Vue</a></div><div><a href="/tag/Frontend/1">Frontend</a></div><div><a href="/tag/React/1">React</a></div></div></div><div><p>[迁移自博客园] | 小心 Web 前端，快跑！</p><span id="more"></span><h2 id="http-请求"><a class="markdownIt-Anchor" href="#http-请求"></a> HTTP 请求</h2><p>鉴权字段可通过设置请求拦截器附加到请求头，一个参考写法如下：</p><pre class="highlight"><code class="js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">request</span>) =&gt;</span> &#123;
    request.<span class="hljs-property">baseURL</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>;
    <span class="hljs-keyword">const</span> session = store.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;session/session&#x27;</span>];
    <span class="hljs-keyword">if</span> (session !== <span class="hljs-literal">null</span> &amp;&amp; session !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;
      request.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Token&#x27;</span>] = session;
      request.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] = <span class="hljs-string">&#x27;application/json&#x27;</span>;
    &#125;
    <span class="hljs-keyword">return</span> request;
  &#125;,
  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
  &#125;
);
</code></pre><p>请求错误处理可通过设置响应拦截器完成，需要注意的两点是：</p><ul><li>如果需要实现诸如与后端对时等需求，也可以通过响应拦截器完成。</li><li>如果发现鉴权字段失效（即返回 401 时），需要清除当前鉴权字段并重定向到登录页面。为优化用户体验，还可以记录当前路由（以 Get 传参的方式），登录后自动返回原来的页面。</li></ul><p>一个参考写法如下：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMessage</span> = (<span class="hljs-params">data, name</span>) =&gt; &#123;
  <span class="hljs-keyword">if</span> (name) &#123;
    <span class="hljs-keyword">return</span> data ? name + <span class="hljs-string">&#x27;错误: &#x27;</span> + data : <span class="hljs-string">&#x27;请求失败：未知的&#x27;</span> + name + <span class="hljs-string">&#x27;错误&#x27;</span>;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> data ? <span class="hljs-string">&#x27;请求错误: &#x27;</span> + data : <span class="hljs-string">&#x27;请求失败：未知的错误&#x27;</span>;
  &#125;
&#125;;

axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> response;
  &#125;,
  <span class="hljs-keyword">async</span> (error) =&gt; &#123;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) &#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-number">400</span> &lt;= error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &lt; <span class="hljs-number">500</span>) &#123;
        <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;
          <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:
            store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;session/setSession&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
            <span class="hljs-keyword">if</span> (router.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">fullPath</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/login&#x27;</span>))
              <span class="hljs-keyword">await</span> router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">redirect</span>: router.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">fullPath</span> &#125; &#125;);
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败：您没有要求的身份验证凭证&#x27;</span>);
          <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败：您没有权限进行这个操作&#x27;</span>);
          <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败：您所请求的资源无法找到&#x27;</span>);
          <span class="hljs-keyword">case</span> <span class="hljs-number">405</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败：您所请求的方法被禁止&#x27;</span>);
          <span class="hljs-attr">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">getMessage</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>, <span class="hljs-string">&#x27;客户端&#x27;</span>));
        &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">500</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">getMessage</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>, <span class="hljs-string">&#x27;服务端&#x27;</span>));
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">getMessage</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>));
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">getMessage</span>(error));
  &#125;
);
</code></pre><p>在此基础上，可以对常用请求方式进行封装，例如：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRequest</span>(<span class="hljs-params">url, params</span>) &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(url, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-attr">params</span>: params &#125;);
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;message/error&#x27;</span>, &#123; <span class="hljs-attr">text</span>: error &#125;);
  &#125;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">postRequest</span>(<span class="hljs-params">url, data</span>) &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(url, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-attr">data</span>: data &#125;);
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;message/error&#x27;</span>, &#123; <span class="hljs-attr">text</span>: error &#125;);
  &#125;
&#125;
</code></pre><h2 id="前端路由"><a class="markdownIt-Anchor" href="#前端路由"></a> 前端路由</h2><p>前置路由守卫的参考处理逻辑如下：</p><ol><li>检查目标路由是否非登录页面路由且不需要鉴权，如果非登录页面路由且不需要鉴权，可直接放行。</li><li>如果目标路由是登录页面路由：<ol><li>如果不存在鉴权信息（只判断存在性，不判断合法性），因为目标是登录页面，直接放行。</li><li>如果存在鉴权信息（即使不合法），重定向到登录后默认页面，因为前端无法判断鉴权信息是否合法，而在重定向到登录页面后，往往会在 Created 阶段或 Mounted 阶段向后端发出请求，如果请求中附带的鉴权信息有误，响应拦截将删除现有鉴权信息，并再次重定向到登录页面，此时由于不存在鉴权信息，将按照规则 2.i 直接放行到登录页面。</li></ol></li><li>如果目标路由非登录页面路由：<ol><li>如果不存在鉴权信息（只判断存在性，不判断合法性），重定向到登录页面，此时由于不存在鉴权信息，将按照规则 2.i 直接放行。与响应拦截类似，为优化用户体验，还可以记录当前路由（以 Get 传参的方式），登录后自动返回原来的页面。</li><li>如果存在鉴权信息（即使不合法），直接放行。因为前端无法判断鉴权信息是否合法，而在重定向到登录页面后，往往会在 Created 阶段或 Mounted 阶段向后端发出请求，如果请求中附带的鉴权信息有误，响应拦截将删除现有鉴权信息，并再次重定向到登录页面，此时由于不存在鉴权信息，将按照规则 2.i 直接放行到登录页面。</li></ol></li></ol><p>请注意，让没登录的用户登录很重要，让登录了的用户不用重新登录同样很重要（例如一个用户收藏了登录页面，如果没有规则 2.i，这个用户每次通过收藏夹访问网站，都需要重新登录一次，即使这个用户此前已经登录过）。</p><p>一个参考写法（Vue Router）如下：</p><pre class="highlight"><code class="js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">let</span> token = store.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;session/session&#x27;</span>];
  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;
    <span class="hljs-keyword">if</span> (token === <span class="hljs-literal">null</span> || token === <span class="hljs-string">&#x27;&#x27;</span>) &#123;
      <span class="hljs-title function_">next</span>();
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-title function_">next</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;);
    &#125;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">if</span> (token === <span class="hljs-literal">null</span> || token === <span class="hljs-string">&#x27;&#x27;</span>) &#123;
      <span class="hljs-title function_">next</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">redirect</span>: to.<span class="hljs-property">fullPath</span> &#125; &#125;);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-title function_">next</span>();
    &#125;
  &#125;
&#125;);
</code></pre><p>后置路由守卫的工作比较琐碎，一些可以考虑放在后置路由守卫处理的工作包括：</p><ul><li>根据目标页面的名字设置 <code>document.title</code>。</li><li>根据目标页面的要求添加或删除某些 <code>class</code>，以更新样式。</li></ul><p>请注意，在前后端分离架构下，隐藏路由不是很方便且在大多数情况下是不必要的。实际上，只要后端做好鉴权工作，并不需要对路由额外进行处理（如在路由守卫中通过 HTTP 请求验证鉴权信息的合法性）。</p><p>一个参考写法（Vue Router）如下：</p><pre class="highlight"><code class="js">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i.<span class="hljs-property">meta</span>[<span class="hljs-string">&#x27;title&#x27;</span>]).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">const</span> titles = to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i.<span class="hljs-property">meta</span>[<span class="hljs-string">&#x27;title&#x27;</span>]);
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = [<span class="hljs-string">&#x27;Frontend&#x27;</span>, ...titles].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; - &#x27;</span>).<span class="hljs-title function_">trim</span>();
  &#125;
&#125;);
</code></pre><p>此外，在路由较为复杂的情况下，为良好的维护多级导航菜单，一个优雅的做法是，在路由中设置一个字段控制是否在导航菜单显示这个路由，再实现一个从路由到导航菜单对象的方法，如此即可避免维护两份数据。</p><h2 id="状态存储"><a class="markdownIt-Anchor" href="#状态存储"></a> 状态存储</h2><p>状态存储主要包括针对当前会话的数据（可存储于浏览器内存中，仅这个会话使用）和针对全部会话的数据（即持久化，可存储于 Cookie 或 LocalStorage 中，使用这个套接字的所有会话公用）。</p><p>针对当前会话的数据可能包括：</p><ul><li>各个表格中，用户当前所在/离开时所在的页码。</li><li>各个表格中，用户当前使用/离开时使用的筛选器。</li></ul><p>针对全部会话的数据可能包括：</p><ul><li>用户的可访问内容和鉴权信息。</li><li>用户的基本信息，如用户 ID、用户名、用户头像链接等。</li></ul><p>需要根据需求灵活选择的数据可能包括：</p><ul><li>页面存在 Tabs 时，用户当前所在/离开时所在的位置。</li><li>Radio Group 或 Checkbox 用户当前处于/离开时处于的选择。</li></ul><p>请注意，无论是 Vue 还是 React，其状态存储工具都有持久化存储支持，此处无需自己造轮子。</p><h2 id="组件库相关"><a class="markdownIt-Anchor" href="#组件库相关"></a> 组件库相关</h2><h3 id="vue-组件库"><a class="markdownIt-Anchor" href="#vue-组件库"></a> Vue 组件库</h3><h4 id="element-人生若只如初见"><a class="markdownIt-Anchor" href="#element-人生若只如初见"></a> Element / 人生若只如初见</h4><ul><li><a href="https://element.eleme.cn/#/zh-CN">Element UI</a> 和 <a href="https://element-plus.gitee.io/zh-CN/">Element Plus</a> 分别面向 <a href="https://element.eleme.cn/#/zh-CN">Vue 2</a> 和 <a href="https://element-plus.gitee.io/zh-CN/">Vue 3</a>。</li><li>设计上倾向于把东西尽可能塞到 <code>template</code> 里面，对于比较熟悉 HTML 不太熟悉 JavaScript 和 Vue 的初学者（比如当时的我），上手起来比较舒服。</li><li>组件种类还行，质量上感觉有点粗糙，日常需要覆盖里面的样式；自带了一个图标库，但感觉不太够用。</li></ul><h4 id="vuetify-为伊消得人憔悴"><a class="markdownIt-Anchor" href="#vuetify-为伊消得人憔悴"></a> Vuetify / 为伊消得人憔悴</h4><ul><li>主要支持 <a href="https://vuetify.cn/zh-Hans/">Vue 2</a>，Vue 3 版本截至目前（2022.11）在 Beta 阶段。</li><li>组件质量相当高，提供的样式和动画不要太爽，基本不用写样式，比较不爽的是，没有回到顶部，没有滚动条，尤其是没有全局消息，需要人工封装一下。</li><li>笔者感觉 Vuetify 比较适合写信息密度比较小的、面向客户的前端，写信息密度比较大的、面向管理者的前端比较痛苦。</li><li>同样附带了图标库，比 Element 全面太多了，绝大多数情况下都够用（就是查图标的网站有点慢）。此外，Vuetify 的文档把组件介绍和组件 API 分开放了，笔者不太喜欢这个处理。</li></ul><h4 id="quasar-家花不如野花香"><a class="markdownIt-Anchor" href="#quasar-家花不如野花香"></a> Quasar / 家花不如野花香</h4><ul><li><a href="http://v1.quasarchs.com/">Vue 2</a> 和 <a href="http://www.quasarchs.com/">Vue 3</a> 都有支持。</li><li>写软工的时候考虑过这个组件库，不过后来还是选了 Vuetify。现在看来这个组件库好厉害，风格同样是 Material Design，和 Vuetify 类似，Vuetify 有的它有，Vuetify 没有的它也有。</li><li>比起 Vuetify，用 Quasar 写信息密度比较大的、面向管理者的前端体验应该会有不少提升。</li></ul><h4 id="naive-ui-这就是恋爱的感觉吗"><a class="markdownIt-Anchor" href="#naive-ui-这就是恋爱的感觉吗"></a> Naive UI / 这就是恋爱的感觉吗</h4><ul><li>不支持 Vue 2，只支持 <a href="https://www.naiveui.com/zh-CN/os-theme">Vue 3</a>。</li><li>设计上倾向于把东西尽可能塞到 <code>script</code> 里面，对于熟悉 Render、JSX 或使用过 React 的人，上手起来比较舒服，对于初学者则可能比较痛苦（Naive UI 的数据表格自定义是传 Render 函数的）。</li><li>功能不输 Vuetify，文档相当圈粉，笔者相比于 Material Design 更喜欢 Naive UI 的设计风格。美中不足的是，Naive UI 没有像 Vuetify 那样提供内置的样式和动画，还是需要手写样式，好在不至于像 Element 那样去覆盖组件库的样式。</li><li>不同于 Vuetify，笔者感觉 Naive UI 比较适合写信息密度比较大的、面向管理者的前端，当然也可以胜任信息密度比较小的、面向客户的前端。</li><li>推荐使用的 xicons 图标库，全面程度超过了 Material Design Icons，应该是笔者见过的最丰富的图标库。</li></ul><h4 id="iview-我囸你仙人"><a class="markdownIt-Anchor" href="#iview-我囸你仙人"></a> iView / 我囸你仙人</h4><ul><li>曾经支持 <a href="http://v2.iviewui.com/">Vue 2</a>（仙人说的就是你），现在只支持 <a href="https://www.iviewui.com/">Vue 3</a>。</li><li>可以视为文档不那么可爱，风格不那么可爱，Bug 多一些（笔者感觉），但内置了一些样式和动画可以少写一些样式，没那么多 Render 和 JSX 的 Naive UI，定位也类似 Naive UI，更适合信息密度比较大的、面向管理者的前端。</li><li>提到它就不得不提它那两年前停止维护的仙人，拜它仙人所赐，有一个三年前停止维护的 iView Admin 被应用于某平台前端，在维护过程中给笔者带来了难以磨灭的心理阴影，我的评价是累了，毁灭吧。</li><li>顺便，无论是曾经的 iView Admin 还是现在的 Admin Plus，里面提供的来路不明神奇 Markdown 编辑器都毫不设防 XSS，直接 <code>&lt;img src=x onerror=&quot;alert('XSS')&quot; /&gt;</code> 即可抬走，项目里还可以寻觅到内容用户可控的 <code>v-html</code> 的踪迹，就这还有脸闭源要授权，我不懂，但我大受震撼。</li></ul><h4 id="antd-vue-爱屋及乌"><a class="markdownIt-Anchor" href="#antd-vue-爱屋及乌"></a> Antd-vue / 爱屋及乌</h4><ul><li>曾经支持 <a href="https://1x.antdv.com/docs/vue/introduce-cn/">Vue 2</a>（不咋维护了），现在只支持 <a href="https://www.antdv.com/components/overview-cn">Vue 3</a>。</li><li>虽然 Antd 本身是 React 的组件库，Antd-vue 并没有把东西尽可能塞到 <code>script</code> 里面，反而倾向于把东西尽可能塞到 <code>template</code> 里面，并不要求使用者熟悉 Render、JSX 或使用过 React。</li><li>笔者用的不多，感觉体验介于 Naive UI 和 iView 之间，如果喜欢 Antd 的风格不妨试试。</li></ul><h4 id="vant-该出手时就出手"><a class="markdownIt-Anchor" href="#vant-该出手时就出手"></a> Vant / 该出手时就出手</h4><ul><li><a href="https://vant-contrib.gitee.io/vant/v2/#/zh-CN/">Vue 2</a> 和 <a href="https://vant-contrib.gitee.io/vant/#/zh-CN/">Vue 3</a> 和<a href="https://vant-contrib.gitee.io/vant-weapp/#/home">微信小程序</a>都有支持。</li><li>面向移动端的组件库，有内置图标，笔者用的不多，目前感觉组件挺齐全，质量也还行。</li><li>对 PC 端的支持很一般，如果前端需要同时支持 PC 端和移动端又不想装两套组件库的话，在 PC 端组件库的基础上调整样式做移动端支持方便一些。</li></ul><h3 id="react-组件库"><a class="markdownIt-Anchor" href="#react-组件库"></a> React 组件库</h3><h4 id="antd-弱水三千只取一瓢饮"><a class="markdownIt-Anchor" href="#antd-弱水三千只取一瓢饮"></a> Antd / 弱水三千只取一瓢饮</h4><ul><li>Antd 设计部分的全局样式、设计模式有不错的参考价值；笔者最常用的<a href="https://ant.design/docs/spec/colors-cn">参考色板</a>亦出自于此。</li><li>相比于最新的 <a href="https://ant.design/index-cn">5.x 版本</a>， 笔者更喜欢 <a href="https://4x.ant.design/index-cn">4.x 版本</a> 的风格。</li><li>笔者 React 写的没有 Vue 多，目前用且仅用过这个组件库。相比于学 Vue 的时候第一个用的 Element，Antd 体验可好太多了。</li></ul><p>React 笔者用的比较少，玩过的组件库也比较少，以后有机会再补。</p><h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h2><h3 id="代码风格检查"><a class="markdownIt-Anchor" href="#代码风格检查"></a> 代码风格检查</h3><p>建议使用 ESLint 和 Prettier 进行代码风格检查，以最大程度保障队友的血压，一个参考的配置如下：</p><pre class="highlight"><code class="js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">printWidth</span>: <span class="hljs-number">120</span>,
  <span class="hljs-attr">tabWidth</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">useTabs</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">singleQuote</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">semi</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">trailingComma</span>: <span class="hljs-string">&#x27;none&#x27;</span>,
  <span class="hljs-attr">bracketSpacing</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">endOfLine</span>: <span class="hljs-string">&#x27;auto&#x27;</span>
&#125;;
</code></pre><h3 id="源代码映射"><a class="markdownIt-Anchor" href="#源代码映射"></a> 源代码映射</h3><p>SourceMap 维护了打包前后的代码映射关系。开发环境下，SourceMap 有利于定位 Bug；生产环境下，SourceMap 会增加传输开销，同时等价于公开了全部未打包的源代码，增加了受攻击的风险，因而生产环境下建议关闭 SourceMap：</p><ul><li>对于 React，可在 <code>.env</code> 中进行配置。</li><li>对于 Vue，可在 <code>vue.config.js</code> 中进行配置。</li></ul><h3 id="鉴权机制"><a class="markdownIt-Anchor" href="#鉴权机制"></a> 鉴权机制</h3><p>基于 Token 的验证是无状态的，其本意在于避免服务端存储 Session，从而解决性能问题和多个后端一致性的问题，但其存在两个难以应对的场景：</p><ul><li>如果用户退出登录，无法方便的注销退出登录的 Token，因此还是要把 Token 存数据库来实现注销。</li><li>如果用户修改密码，无法方便的注销用户所有的 Token，以 JWT 为例，即使在 Payload 中存储了加盐安全哈希后的密码，验证时还是要查一次数据库。</li></ul><p>上述情况中，基于 Token 进行验证时难免需要访问数据库，这就违背了 Token 无状态的初衷。为解决此问题，一种方式是设置 Refresh Token 存储在数据库，并在需要时失效 Refresh Token，另一种方式是使用 Session 并使用 Redis 存储，其好处在于：</p><ul><li>Redis 性能优秀，且提供了一致性问题的解决方案。</li><li>解耦后端、缓存数据库与主数据库，如需要下线全部用户只要重启 Redis；如需变动其它服务不会影响用户的登录状态。</li></ul><p>顺便，如果真打算用 JWT，还是要稍微了解一下 JWT 的原理，别把用户密码放 Payload 里面去了（真见过这么干的）。</p><h3 id="加密相关"><a class="markdownIt-Anchor" href="#加密相关"></a> 加密相关</h3><p>在只有服务端和用户端，没有可信第三方的情况下（公钥是后端发给前端的），前后端传输数据时进行加密是没有意义的，总可以进行中间人攻击（攻击者只要分析清楚前端如何解密后端发来的请求，如何加密请求发给后端即可）。此外，由于 TLS 协议的存在，使用 HTTPS 的情况下请求实际上是经过加密的，这一过程对程序员透明，无需进行额外处理。</p><p>但在前后端传输数据时进行加密也不是完全没有意义，传输过程中加密一方面可以一定程度上拉高攻击者的门槛，另一方面可以减少第三方实现的“前端”（脚本），参考某选课平台，这一点不难理解。</p><p>因此，请求过程中是否加密实际上取决于实际需求，即鼓励/无所谓第三方实现的“前端”还是不希望出现第三方实现的“前端”。而在具体实现上，为尽可能提高攻击门槛，可以考虑对公钥进行混淆处理，增加逆向难度。</p><p>而出于性能考虑，相比直接使用非对称加密，使用对称加密加密请求，再使用非对称加密加密对称加密的密钥更加高效。同时，使用对称加密加密请求时，最好不要选择电码本（ECB）模式，引用可证明安全课件中的一张图：</p><img src="/assets/images/ecb-mode.png" alt="ECB 模式加密的图片" width="60%"><p>也不知道是哪家公司写的某选课平台，总之建议开发者重修一下密码学。</p></div><div>Word count: 4.1k</div><div>Reading time: 16min</div><div><div><a href="/archive/2022/11/1">Created 2022-11-02T14:14:46.000Z</a></div></div><div><div><a href="/archive/2022/11/1">Last Modified 2022-11-02T14:14:46.000Z</a></div></div><div><br><br></div></div></content><div><br></div><footer>Copyright © 2021-2023 Chenrt Blog</footer></noscript><div id="app"></div></body></html>