<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Chenrt"><meta name="keywords" content="Chenrt, @Chenrt, Chenrt Blog, 计算机, 网络安全, 博客, 个人网站"><meta name="description" content="Chenrt 的个人博客"><meta name="generator" content="Hexo"><link rel="icon" href="/favicon.svg"><title>Chenrt の 小窝 - 软件工程第三次博客作业 | 杰对编程</title><script defer="defer" src="/js/chunk-vendors.js"></script><script defer="defer" src="/js/app.js"></script><link href="/css/chunk-vendors.css" rel="stylesheet"><link href="/css/app.css" rel="stylesheet"></head><body><noscript><header><nav><a href="/">Home</a></nav><nav><a href="/blogs/1">Blogs</a></nav><nav><a href="/category">Categories</a></nav><nav><a href="/tag">Tags</a></nav><nav><a href="/archive">Archives</a></nav><nav><a href="/about">About</a></nav><nav><a href="/apis">Api</a></nav></header><div><br></div><content><div><a href="/blog/65c84d81dea5"><h1>软件工程第三次博客作业 | 杰对编程</h1></a><div><div><div><a href="/category/Buaa/1">Buaa</a></div><div><a href="/category/Buaa/SE/1">SE</a></div></div></div><div><div><div><a href="/tag/C++/1">C++</a></div><div><a href="/tag/Visual Studio/1">Visual Studio</a></div></div></div><div><p>[迁移自博客园] | BUAA 2021-2022 Software Engineering Homework 3</p><span id="more"></span><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:left">这个作业属于哪个课程</td><td style="text-align:left"><a href="https://bbs.csdn.net/forums/BH-SE">软件工程</a></td></tr><tr><td style="text-align:left">这个作业的要求在哪里</td><td style="text-align:left"><a href="https://bbs.csdn.net/topics/605443466">结对编程项目-最长英语单词链</a></td></tr><tr><td style="text-align:left">我在这个课程的目标是</td><td style="text-align:left">提高工程能力，练习团队开发</td></tr><tr><td style="text-align:left">这个作业在哪个具体方面帮助我实现目标</td><td style="text-align:left">体验结对编程，提高工程能力</td></tr></tbody></table><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><blockquote><p>在文章开头给出教学班级和可克隆的 GitHub 项目地址（例子如下）。（1’）</p><ul><li>教学班级：周二班</li><li>项目地址：<a href="https://github.com/github/platform-samples.git">https://github.com/github/platform-samples.git</a></li></ul></blockquote><ul><li>教学班级：周五班</li><li>项目地址：<a href="https://github.com/Chenrt-ggx/WordListProject">https://github.com/Chenrt-ggx/WordListProject</a></li></ul><h2 id="预估耗时"><a class="markdownIt-Anchor" href="#预估耗时"></a> 预估耗时</h2><blockquote><p>在开始实现程序之前，在下述 PSP 表格记录下你估计将在程序的各个模块的开发上耗费的时间。（0.5’）</p></blockquote><table><thead><tr><th style="text-align:left">PSP 2.1</th><th style="text-align:center">Personal Software Process Stages</th><th style="text-align:center">预估耗时（分钟）</th></tr></thead><tbody><tr><td style="text-align:left">Planning</td><td style="text-align:center">计划</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">      Estimate</td><td style="text-align:center">估计这个任务需要多少时间</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">Development</td><td style="text-align:center">开发</td><td style="text-align:center">1030</td></tr><tr><td style="text-align:left">      Analysis</td><td style="text-align:center">需求分析（包括学习新技术）</td><td style="text-align:center">120</td></tr><tr><td style="text-align:left">      Design Spec</td><td style="text-align:center">生成设计文档</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">      Design Review</td><td style="text-align:center">设计复审（和同事审核设计文档）</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">      Coding Standard</td><td style="text-align:center">代码规范（为目前的开发制定合适的规范）</td><td style="text-align:center">30</td></tr><tr><td style="text-align:left">      Design</td><td style="text-align:center">具体设计</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">      Coding</td><td style="text-align:center">具体编码</td><td style="text-align:center">300</td></tr><tr><td style="text-align:left">      Code Review</td><td style="text-align:center">代码复审</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">      Test</td><td style="text-align:center">测试（自我测试，修改代码，提交修改）</td><td style="text-align:center">300</td></tr><tr><td style="text-align:left">Reporting</td><td style="text-align:center">报告</td><td style="text-align:center">190</td></tr><tr><td style="text-align:left">      Test Report</td><td style="text-align:center">测试报告</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">      Size Measurement</td><td style="text-align:center">计算工作量</td><td style="text-align:center">30</td></tr><tr><td style="text-align:left">      Postmortem &amp; Process Improvement Plan</td><td style="text-align:center">事后总结, 并提出过程改进计划</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">合计</td><td style="text-align:center">1280</td></tr></tbody></table><h2 id="设计与实现"><a class="markdownIt-Anchor" href="#设计与实现"></a> 设计与实现</h2><h3 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h3><blockquote><p>看教科书和其它资料中关于 Information Hiding，Interface Design，Loose Coupling 的章节，说明你们在结对编程中是如何利用这些方法对接口进行设计的。（5’）</p></blockquote><p>首先需要指出，至少在基本完成这个项目（4.1）之前，我们无权对接口进行设计，因为指导书已经给定了接口。虽然我们没有利用这些方法对接口进行设计，但我们利用这些方法和课程组据理力争，使官方接口得到了修改，具体如下。</p><p>我们来看第一版指导书给出的接口：</p><ul><li><code>int gen_chain_word(char words[], int len, char result[], char head, char tail, bool enable_loop)</code></li><li><code>int gen_chains_all(char words[], int len, char result[])</code></li><li><code>int gen_chain_word_unique(char words[], int len, char result[])</code></li><li><code>int gen_chain_char(char words[], int len, char result[], char head, char tail, bool enable_loop)</code></li></ul><p>接口中的 word 是一个字符串，也就是要把整个文件读到内存之后以字符串的形式传入，也就是说“分词”这个工作是由“计算核心”完成的，这样有利于信息隐藏吗？这样是否松耦合呢？</p><p>接口中的 result 也一个字符串，也就是在完成计算之后，要把结果转换并合并成一个字符串返回，这样有利于扩展吗？这样是否松耦合呢？当然这些都不重要，最关键的是，result 既不是指针又不是引用，“计算核心”是无法改变 result 的值的，也就是 result 是外部开辟好的，那么 result 要开多大呢？</p><p>总之，经过同学们反复据理力争，接口修改如下：</p><ul><li><code>int gen_chain_word(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code></li><li><code>int gen_chains_all(char* words[], int len, char* result[])</code></li><li><code>int gen_chain_word_unique(char* words[], int len, char* result[])</code></li><li><code>int gen_chain_char(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code></li></ul><p>这样一来，words 是一个字符指针数组，数组里的每一个元素是一个字符串的指针，是比较清晰和自然的，但 result 此时存在二义性，且无论怎么解释都存在问题：</p><ul><li>如果认为 result 是一个指向字符串的指针，这样我们就可以在 core 中动态申请空间用于存储结果了，但问题是依然要把结果转换并合并成一个字符串返回。</li><li>如果认为 result 是一个字符指针数组，数组里面的每一个元素就是一个字符指针，这样避免了把结果转换并合并成一个字符串返回，但问题是我们仍然不知道 result 要开多大。</li></ul><p>课程组的解决方案是确定 result 开 20000，但这不过是一个不怎么工程权宜之计，我们至少可以如下修改接口，实现在 core 中动态申请空间用于存储结果：</p><ul><li><code>int gen_chain_word(char* words[], int len, char*** result, char head, char tail, bool enable_loop)</code></li><li><code>int gen_chains_all(char* words[], int len, char*** result)</code></li><li><code>int gen_chain_word_unique(char* words[], int len, char*** result)</code></li><li><code>int gen_chain_char(char* words[], int len, char*** result, char head, char tail, bool enable_loop)</code></li></ul><p>如果不考虑跨语言的话，还可以通过引用完成：</p><ul><li><code>int gen_chain_word(char* words[], int len, char**&amp; result, char head, char tail, bool enable_loop)</code></li><li><code>int gen_chains_all(char* words[], int len, char**&amp; result)</code></li><li><code>int gen_chain_word_unique(char* words[], int len, char**&amp; result)</code></li><li><code>int gen_chain_char(char* words[], int len, char**&amp; result, char head, char tail, bool enable_loop)</code></li></ul><p>或者干脆使用 vector 完成：</p><ul><li><code>void gen_chain_word(vector&lt;char*&gt; words, vector&lt;char*&gt;&amp; result, char head, char tail, bool enable_loop)</code></li><li><code>void gen_chains_all(vector&lt;char*&gt; words, vector&lt;char*&gt;&amp; result)</code></li><li><code>void gen_chain_word_unique(vector&lt;char*&gt; words, vector&lt;char*&gt;&amp; result)</code></li><li><code>void gen_chain_char(vector&lt;char*&gt; words, vector&lt;char*&gt;&amp; result, char head, char tail, bool enable_loop)</code></li></ul><h3 id="接口实现"><a class="markdownIt-Anchor" href="#接口实现"></a> 接口实现</h3><blockquote><p>计算模块接口的设计与实现过程。设计包括代码如何组织，比如会有几个类，几个函数，他们之间关系如何，关键函数是否需要画出流程图？说明你的算法的关键（不必列出源代码），以及独到之处。（7’）</p></blockquote><p>课程组在结对编程后期调整了指导书，允许自定义接口，但此时我们的 core 已经基本完成，因此仍然使用了课程组规定的接口：</p><ul><li><code>int gen_chain_word(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code></li><li><code>int gen_chains_all(char* words[], int len, char* result[])</code></li><li><code>int gen_chain_word_unique(char* words[], int len, char* result[])</code></li><li><code>int gen_chain_char(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code></li></ul><p>下面是各个字段的含义：</p><ul><li><code>words</code> 字段：传入的字符指针数组，每个元素是一个字符指针，指向一个单词。</li><li><code>len</code> 字段：传入的字符指针数组的长度。</li><li><code>result</code> 字段：存储结果的字符指针数组，由调用者开辟，大小为 20000。<ul><li>对于 <code>gen_chains_all</code>，如果结果数量超过 20000 则为空，否则每一个元素是一个合并后的单词链，单词链占用的空间由 core 申请，后一次调用时释放前一次调用申请的空间。</li><li>对于 <code>gen_chain_word</code>、<code>gen_chain_word_unique</code>、<code>gen_chain_char</code>，每一个元素是一个单词，且单词的地址来自 words。</li></ul></li><li><code>head</code> 字段：指定单词链的首字母，不是小写字母则表明没有限制。</li><li><code>tail</code> 字段：指定单词链的尾字母，不是小写字母则表明没有限制。</li><li><code>enable_loop</code> 字段：指定是否允许输入中存在环。</li></ul><p>计算模块接口的实现上，考虑到问题只是有些琐碎而并不复杂，我们采用面向过程的方式，设置了两个类、十三个函数。</p><p>两个类 Node 和 Chain 分别为单词和单词链的封装，通过缓存一些单词和单词链的特征加速计算：</p><pre class="highlight"><code class="c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>
&#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> len;
    <span class="hljs-type">int</span> status;
    <span class="hljs-type">char</span>* word;
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// ......</span>
&#125;;
</code></pre><pre class="highlight"><code class="c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chain</span>
&#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> char_len;
    vector&lt;Node*&gt; word_vector;
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// ......</span>
&#125;;
</code></pre><p>涉及 <code>gen_chains_all</code> 的函数有三个：</p><ul><li><code>int gen_chains_all(char* words[], int len, char* result[])</code>，为入口。</li><li><code>void chains_all_dfs(const int now, Chain&amp; chain)</code>，由入口调用，递归搜索满足条件的单词链。</li><li><code>void output_chain(const Chain&amp; chain)</code>，将单词链合并形成字符串以通过 result 返回。</li></ul><p>涉及 <code>gen_chain_word</code> 和 <code>gen_chain_char</code> 的函数有四个：</p><ul><li><code>int gen_chain_word(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code>，为入口。</li><li><code>int gen_chain_char(char* words[], int len, char* result[], char head, char tail, bool enable_loop)</code>，为入口。</li><li><code>int abstract_gen_chain(char* words[], const int len, char* result[], const char head, const char tail, const bool enable_loop, const bool by_word)</code>，由两个入口使用不同的 <code>by_word</code> 调用。</li><li><code>gen_chain_dfs</code>，由 <code>abstract_gen_chain</code> 调用，递归搜索满足条件的单词链。</li></ul><p>涉及 <code>gen_chain_word_unique</code> 的函数有两个：</p><ul><li><code>void chain_word_unique_dfs(const int now, Chain&amp; chain, Chain&amp; max_chain)</code>，为入口。</li><li><code>int gen_chain_word_unique(char* words[], int len, char* result[])</code>，由入口调用，递归搜索满足条件的单词链。</li></ul><p>其它四个函数为公用函数：</p><ul><li><code>void build_graph(char* words[], const int word_count)</code>，用于建图。</li><li><code>bool check_cycle()</code>，用于判环并返回错误。</li><li><code>bool check_cycle_dfs(const int now)</code>，由 <code>check_cycle</code> 调用，递归搜索环。</li><li><code>void replace_max_chain(const Chain&amp; chain, Chain&amp; max_chain, const bool by_word)</code>，根据单词数量或长度更新最长单词链。</li></ul><p>我们了采用普通的图上深度优先搜索算法，采用邻接矩阵存储有向图，并通过合并自环以优化性能，这些对于<strong>熟练掌握 C 语言</strong>的<strong>计算机专业</strong>本科生而言并没有什么理解难度，因此就不画流程图了。</p><h3 id="uml-关系图"><a class="markdownIt-Anchor" href="#uml-关系图"></a> UML 关系图</h3><blockquote><p>阅读有关 UML 的内容，画出 UML 图显示计算模块部分各个实体之间的关系（画一个图即可）。（2’）</p><ul><li><a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">https://en.wikipedia.org/wiki/Unified_Modeling_Language</a></li></ul></blockquote><p>下面的内容摘自维基百科，可见 UML 图是一类图的总称，而不是具体的某一种图，这个问题中“画出 UML 图”本身就存在问题。</p><blockquote><p>UML 2 has many types of diagrams, which are divided into two categories.</p></blockquote><p>翻了一下往年博客，姑且认为这里让我们画的是“类图（Class Diagram）”。</p><img src="/assets/images/buaa-se/hw3/uml.svg" width="80%"><h3 id="界面设计"><a class="markdownIt-Anchor" href="#界面设计"></a> 界面设计</h3><blockquote><p>界面模块的详细设计过程。在博客中详细介绍界面模块是如何设计的，并写一些必要的代码说明解释实现过程。（5’）</p></blockquote><ul><li><p>CLI 部分</p><p>命令行的界面模块分为四个子过程：解析命令行参数，解析文件，调用函数与输出。</p><p>在最初设计的时候我们就同意应当将界面分成这四个部分分别开发。于是我们首先写了参数解析部分，并且用了很多样例来测试程序是否正确的解析了参数、是否正确的检测出错误等，我们还发现了一个特殊的样例：</p><pre class="highlight"><code class="plain">Wordlist.exe -w -c
</code></pre><p>这个样例具有两个正确的解读，一个是找出 -w 这个文件的最大单词字母链，另一个是找出 -c 这个文件的最大单词数链，产生了二义性。据此与老师进行反馈后增加了“打开的文件必须以 .txt 结尾”的特殊限制，解除了这个冲突，我们将首先判断某个参数是否以 .txt 结尾来决定其是否是文件，然后再判断参数。</p><p>解析文件设计为第一次遍历时处理大小写和特殊字符，第二次遍历找到符合单词定义的字符串，将字符串首地址存入 result。</p><p>错误处理的设计经过了多次变动，最开始我们为了性能采用了返回负值的错误处理方法，不过发现我们会因此多许多不必要的代码，于是后来改成了用 throw 抛出 int 类型错误码的方式，不过又发现这种方式对 DLL 调用的通用性很差（异常不能抛到 Python 里接住）于是就仅在 DLL 的调用接口处设计为返回负值，其他地方仍采用抛出错误码来代表错误。</p><p>阶段一：</p><pre class="highlight"><code class="c++"><span class="hljs-comment">// 第一个函数 parse_params 将命令行参数解析并判断格式错误和重复错误</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_params</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>;

<span class="hljs-comment">// 在确保参数在形式上正确后，conflict_check 函数会对所有 flag 进行细致的存在性检查和冲突检查</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">conflict_check</span><span class="hljs-params">()</span></span>;
</code></pre><p>解析文件：</p><pre class="highlight"><code class="c++"><span class="hljs-comment">// read_file 函数会在充分考虑到异常的情况下将一个文件读取到内存中</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">char</span>*&amp; content, <span class="hljs-type">int</span>&amp; len)</span></span>;

<span class="hljs-comment">// split_content 会正确的将一个装有输入的字符数组的所有非英文字符转换为 &#x27;\0&#x27;，并将大写字母转换为小写字母</span>
<span class="hljs-comment">// 然后会找出所有符合“单词”定义的字符串，将它们的首地址指针放入 result 内</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">split_content</span><span class="hljs-params">(<span class="hljs-type">char</span>* content, <span class="hljs-type">const</span> <span class="hljs-type">int</span> len, <span class="hljs-type">char</span>* result[])</span></span>;
</code></pre><p>调用函数：</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>
</span>&#123;
    <span class="hljs-type">int</span> len;
    <span class="hljs-type">char</span>* content = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* words[<span class="hljs-number">10005</span>]; <span class="hljs-comment">// 有约定称单词数最多不超过 10000 个</span>
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* result[<span class="hljs-number">20005</span>]; <span class="hljs-comment">// 有约定称结果最多不超过 20000 行</span>
    <span class="hljs-keyword">try</span>
    &#123;
        <span class="hljs-built_in">parse_params</span>(argc, argv);
        <span class="hljs-built_in">conflict_check</span>();
        <span class="hljs-built_in">read_file</span>(filename, content, len);
        <span class="hljs-type">int</span> word_count = <span class="hljs-built_in">split_content</span>(content, len, words);
        <span class="hljs-keyword">if</span> (flag_n)
        &#123;
            <span class="hljs-type">int</span> result_len = <span class="hljs-built_in">gen_chains_all</span>(words, word_count, result);
            <span class="hljs-comment">// 此处有接口转换，如果 dll 返回值是负值，则表示有异常，改用 throw 方式与其他异常统一处理</span>
            <span class="hljs-keyword">if</span> (result_len &lt; <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-keyword">throw</span> result_len;
            &#125;
            <span class="hljs-built_in">write_to_screen</span>(result, result_len);
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...
    &#125;
    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> eid)
    &#123;
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* description[] =
        &#123;
            <span class="hljs-string">&quot;unexpected word cycle detected&quot;</span>, <span class="hljs-comment">// 1</span>
            <span class="hljs-string">&quot;...&quot;</span>
        &#125;;
        <span class="hljs-type">int</span> index = ((eid ^ <span class="hljs-number">0x80000000</span>) - <span class="hljs-number">1</span>) % (<span class="hljs-built_in">sizeof</span>(description) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*));
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;expection (id 0x%X) catched: %s\n&quot;</span>, eid, description[index]);
    &#125;
&#125;
</code></pre><p>输出：</p><pre class="highlight"><code class="c++"><span class="hljs-comment">// 将从 core 返回的结果打印到屏幕上</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_to_screen</span><span class="hljs-params">(<span class="hljs-type">char</span>* result[], <span class="hljs-type">const</span> <span class="hljs-type">int</span> len)</span></span>;

<span class="hljs-comment">// 将从 core 返回的结果打印到文件 solutions.txt</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_to_solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* result[], <span class="hljs-type">const</span> <span class="hljs-type">int</span> len)</span></span>;
</code></pre></li><li><p>GUI 部分</p><p>GUI 的设计分为显示模块、接口包装模块、字符处理模块三部分。对于这样一款简单的单页面应用，不必应用 MVC 设计模式，直接将 V(View) 和 C(Controllor) 融合在一起了。</p><p>有关于参数的解析，我们认为避免用户犯错要比让用户犯错之后再提醒更好，前端会自动将冲突的按钮禁用，自动保证首位字母的参数为小写字母，利用文件选取器保证用户一定选择了一个存在的并且可以打开的 .txt 文件。在解析时，会自动将用户输入的非 ASCII 码转换为替代字符 <code>.</code> 来告知用户输入不合法。</p><p>接口包装模块是把 ctypes 调用 DLL 接口的复杂方法转换为 Python 风格的写法。</p><p>字符处理模块处理无害化输入和分词等较为复杂的字符串工作，因为 Python 很强大所以也没写几行；文件的导入和导出与错误检测大部分都由 PyQt 代劳了，所以没有为此单独包装模块。</p></li></ul><h3 id="模块对接"><a class="markdownIt-Anchor" href="#模块对接"></a> 模块对接</h3><blockquote><p>界面模块与计算模块的对接。详细地描述 UI 模块的设计与两个模块的对接，并在博客中截图实现的功能。（4’）</p></blockquote><ul><li><p>core 部分</p><p>core 通过 <code>extern &quot;C&quot; _declspec(dllexport)</code> 将函数导出到动态链接库。</p><p>函数签名与作业题面中一致，words 和 result 指针数组的内存分配由调用者负责，words 内的指针指向的内存由调用者负责管理，result 内的指针指向的内存由被调用者 core 负责管理，core 被调用时在全局区域的一个 <code>vector&lt;string&gt; result_storage</code> 中存储结果并让 result 里的指针指向这一块内存区域，在第二次调用函数时首先会清空 <code>result_storage</code>，回收之前的内存，这样可以保证多次调用内存不泄露。</p><p>调用参数 words 约定为已经处理好的转换为小写的字符串数组；函数的返回值若为正值则与题面描述一致，若为负值则说明 core 报错，错误码在全局中定义。</p></li><li><p>CLI 部分</p><p>CLI 通过 <code>extern &quot;C&quot; _declspec(dllimport)</code> 导入动态链接库中的函数。</p><p>CLI 程序通过解析命令行参数完成对以下字段的填充：</p><pre class="highlight"><code class="c++"><span class="hljs-type">bool</span> flag_n = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> flag_w = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> flag_m = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> flag_c = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> flag_h = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> <span class="hljs-type">flag_t</span> = <span class="hljs-literal">false</span>;
<span class="hljs-type">bool</span> flag_r = <span class="hljs-literal">false</span>;

<span class="hljs-type">char</span> param_h = <span class="hljs-string">&#x27;\0&#x27;</span>;
<span class="hljs-type">char</span> <span class="hljs-type">param_t</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;

<span class="hljs-type">char</span>* filename = <span class="hljs-literal">nullptr</span>;
</code></pre><blockquote><p>迁博客时注：才发现变量以 <code>_t</code> 结尾似乎会让 highlight.js 把变量误判成类型。</p></blockquote><p>接下来读入文件，将文件中的单词切分出来并转换为小写。如果参数无误且文件读取正常，将调用 core 导出的函数，发现有单词环的报错则打印出来，否则将答案按要求输出到文件 solution.txt 或控制台。</p><p>正常的功能实现如下图：</p><img src="/assets/images/buaa-se/hw3/out.png" width="60%"><p>加入了特殊参数以及一些异常的抛出：</p><img src="/assets/images/buaa-se/hw3/err.png" width="60%"></li><li><p>GUI 部分</p><p>GUI 采用 PyQt 编写，通过 Python 的 ctypes 包调用 DLL 中的函数。我们编写了一个接口转换模块，将 C 风格的接口转换为 Python 风格的接口，供其它 Python 模块调取。Python 写字符串处理是很爽的，两行搞定了 C++ 二十几行的处理。GUI 会在用户点击按钮后收集界面上所有的参数，传入内核获取结果后显示在界面上。</p><p>查询最长字母数链：</p><img src="/assets/images/buaa-se/hw3/ui-1.png" width="80%"><p>查询最长单词数链：</p><img src="/assets/images/buaa-se/hw3/ui-2.png" width="80%"><p>允许单词环时禁用 -n 和 -m 选项：</p><img src="/assets/images/buaa-se/hw3/ui-3.png" width="80%"><p>若未开启允许输入单词环的选项且出现了单词环，则会报错：</p><img src="/assets/images/buaa-se/hw3/ui-4.png" width="80%"></li></ul><h2 id="测试与改进"><a class="markdownIt-Anchor" href="#测试与改进"></a> 测试与改进</h2><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><blockquote><p>计算模块部分单元测试展示。展示出项目部分单元测试代码，并说明测试的函数，构造测试数据的思路。并将单元测试得到的测试覆盖率截图，发表在博客中。要求总体覆盖率到 90% 以上，否则单元测试部分视作无效。（6’）</p></blockquote><p>我们设置了测试点 32 个，如下：</p><pre class="highlight"><code class="c++"><span class="hljs-built_in">TEST_METHOD</span>(AllChainNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">1</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(AllChainEmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">7</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(AllChainCycle) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">13</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(AllChainAddition) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">29</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(AllChainExceed) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">30</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ByWordNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">2</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordEmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">8</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordCycle) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">14</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordSetHead) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">17</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordSetTail) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">18</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordSetBoth) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">19</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(UniqueChainNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">3</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(UniqueChainEmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">9</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(UniqueChainCycle) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">15</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(UniqueChainAddition) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">31</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(TestPerformance) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">32</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ByCharNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">4</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharEmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">10</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharCycle) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">16</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharSetHead) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">20</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharSetTail) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">21</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharSetBoth) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">22</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ByWordAllowRNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">5</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordAllowREmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">11</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordAllowRSetHead) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">23</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordAllowRSetTail) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">24</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByWordAllowRSetBoth) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">25</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ByCharAllowRNormal) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">6</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharAllowREmpty) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">12</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharAllowRSetHead) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">26</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharAllowRSetTail) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">27</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ByCharAllowRSetBoth) &#123; <span class="hljs-built_in">core_test_at</span>(<span class="hljs-number">28</span>); &#125;
</code></pre><p>这些测试点均为手工构造，构造思路即为测试点名称，可望文生义，故不再赘述，输入和评测方式存储在文件中（.in 和 .config 格式），由 <code>core_test_at</code> 函数读取和使用：</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">core_test_at</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)</span>
</span>&#123;
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* result[<span class="hljs-number">20000</span>];
    <span class="hljs-built_in">check_testcase</span>(index, <span class="hljs-string">&quot;coretest&quot;</span>);
    string base = <span class="hljs-string">&quot;../../cases/coretest/testcase&quot;</span> + <span class="hljs-built_in">to_string</span>(index);
    <span class="hljs-built_in">read_by_line</span>(base + <span class="hljs-string">&quot;.in&quot;</span>, in_content, in_len);
    <span class="hljs-built_in">read_by_line</span>(base + <span class="hljs-string">&quot;.config&quot;</span>, config_content, config_len);
    <span class="hljs-built_in">parse_config</span>(config_content, config_len, config);
    <span class="hljs-keyword">switch</span> (config.process_method)
    &#123;
    <span class="hljs-keyword">case</span> ALL:
        result_len = <span class="hljs-built_in">gen_chains_all</span>(in_content, in_len, result);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> UNIQUE:
        result_len = <span class="hljs-built_in">gen_chain_word_unique</span>(in_content, in_len, result);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BY_WORD:
        result_len = <span class="hljs-built_in">gen_chain_word</span>(in_content, in_len, result, config.head, config.tail, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BY_WORD_ALLOW_R:
        result_len = <span class="hljs-built_in">gen_chain_word</span>(in_content, in_len, result, config.head, config.tail, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BY_CHAR:
        result_len = <span class="hljs-built_in">gen_chain_char</span>(in_content, in_len, result, config.head, config.tail, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BY_CHAR_ALLOW_R:
        result_len = <span class="hljs-built_in">gen_chain_char</span>(in_content, in_len, result, config.head, config.tail, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">break</span>;
    &#125;
    <span class="hljs-keyword">if</span> (result_len &lt; <span class="hljs-number">0</span>)
    &#123;
        <span class="hljs-built_in">error_code_check</span>(result_len, config);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.check_method == BY_STRING)
    &#123;
        <span class="hljs-built_in">string_check</span>(result, result_len, in_content, in_len, config);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.check_method == BY_UNIQUE)
    &#123;
        <span class="hljs-built_in">unique_check</span>(result, result_len, in_content, in_len, config);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.check_method == BY_WORD_LEN)
    &#123;
        <span class="hljs-built_in">array_check_word</span>(result, result_len, in_content, in_len, config);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.check_method == BY_CHAR_LEN)
    &#123;
        <span class="hljs-built_in">array_check_char</span>(result, result_len, in_content, in_len, config);
    &#125;
    <span class="hljs-built_in">free_content</span>(in_content, in_len);
    <span class="hljs-built_in">free_content</span>(config_content, config_len);
    <span class="hljs-keyword">delete</span> in_content;
    <span class="hljs-keyword">delete</span> config_content;
&#125;
</code></pre><p>对于 <code>gen_chains_all</code> 输出顺序任意，对于其它接口，存在多个满足条件的单词链时可以返回任意一个，因此我们没有固定全部结果，而是只固定了接口的返回值，result 中的内容则通过 SPJ 的方式验证。</p><p>我们设置了以下五种针对 core 的评测逻辑，均可望文生义：</p><ul><li><code>void array_check_word(char* result[], const int result_len, char* input[], const int input_len, const Config&amp; config)</code></li><li><code>void array_check_char(char* result[], const int result_len, char* input[], const int input_len, const Config&amp; config)</code></li><li><code>void unique_check(char* result[], const int result_len, char* input[], const int input_len, const Config&amp; config)</code></li><li><code>void string_check(char* result[], const int result_len, char* input[], const int input_len, const Config&amp; config)</code></li><li><code>void error_code_check(const int result_len, const Config&amp; config)</code></li></ul><p>我们的 SPJ 支持以下评测模式：</p><ul><li><code>void array_unique_check(char* data[], const int data_len)</code> 对数组形式的单词链，检查单词是否没有重复。</li><li><code>void string_unique_check(char data[], const int data_len)</code> 对字符串形式的单词链，检查单词是否没有重复。</li><li><code>void head_unique_check(char* data[], const int data_len)</code> 对数组形式的单词链，检查首字母是否没有重复。</li><li><code>void head_tail_check(char* result[], const int result_len, const Config&amp; config)</code> 对数组形式的单词链，检查首尾字母是否满足 -h 和 -t 的约束。</li><li><code>void array_list_check(char* data[], const int data_len)</code> 对数组形式的单词链，检查每个元素是否是单词（长度大于 1），连在一起是否是单词链。</li><li><code>void string_list_check(char* data, const int data_len)</code> 对字符串形式的单词链，检查每个元素是否是单词（长度大于 1），连在一起是否是单词链。</li><li><code>void array_in_input_check(char* data[], const int data_len, char* input[], const int input_len)</code> 对数组形式的单词链，检查每个元素是否在输入中。</li><li><code>void string_in_input_check(char* data, const int data_len, unordered_set&lt;string&gt;&amp; input)</code> 对字符串形式的单词链，检查每个元素是否在输入中。</li></ul><p>单元测试覆盖率如下：</p><img src="/assets/images/buaa-se/hw3/coverage.jpg"><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><blockquote><p>计算模块部分异常处理说明。在博客中详细介绍每种异常的设计目标。每种异常都要选择一个单元测试样例发布在博客中，并指明错误对应的场景。（5’）</p></blockquote><p>我们设置了十二种异常，其中内核异常一种，CLI 异常十一种：</p><table><thead><tr><th style="text-align:left">异常码</th><th style="text-align:left">异常类型</th><th style="text-align:left">异常说明</th></tr></thead><tbody><tr><td style="text-align:left">0x80000001</td><td style="text-align:left">内核异常</td><td style="text-align:left">输入中存在单词环</td></tr><tr><td style="text-align:left">0x80000002</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">输入了未定义的 Flag</td></tr><tr><td style="text-align:left">0x80000003</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">输入的 Flag 冲突</td></tr><tr><td style="text-align:left">0x80000004</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">必需的 Flag 不存在</td></tr><tr><td style="text-align:left">0x80000005</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">Flag 参数格式错误</td></tr><tr><td style="text-align:left">0x80000006</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">必需的 Flag 参数不存在</td></tr><tr><td style="text-align:left">0x80000007</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">文件名不存在</td></tr><tr><td style="text-align:left">0x80000008</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">文件名存在多个</td></tr><tr><td style="text-align:left">0x80000009</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">文件不存在</td></tr><tr><td style="text-align:left">0x8000000A</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">文件无法打开</td></tr><tr><td style="text-align:left">0x8000000B</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">文件在读入时被修改</td></tr><tr><td style="text-align:left">0x8000000C</td><td style="text-align:left">CLI 异常</td><td style="text-align:left">内存申请失败</td></tr></tbody></table><ul><li><p>0x80000001 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt</code>。</li><li>文件系统：当前目录存在名为 testcase.txt 的文件，此文件可读。</li><li>文件内容：<code>ab bc cd da</code>。</li><li>错误说明：输入内容存在单词环。</li></ul></li><li><p>0x80000002 测试样例</p><ul><li>命令行参数：<code>-w -x testcase.txt</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：-x 未定义。</li></ul></li><li><p>0x80000003 测试样例</p><ul><li>命令行参数：<code>-n -w testcase.txt</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：-n 和 -w 冲突。</li></ul></li><li><p>0x80000004 测试样例</p><ul><li>命令行参数：<code>-r testcase.txt</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：-n、-w、-m、-c 之一必须存在。</li></ul></li><li><p>0x80000005 测试样例</p><ul><li>命令行参数：<code>-w -h % testcase.txt</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：-h 的参数必须是一个字母。</li></ul></li><li><p>0x80000006 测试样例</p><ul><li>命令行参数：<code>testcase.txt -w -h</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：-h 的参数不存在。</li></ul></li><li><p>0x80000007 测试样例</p><ul><li>命令行参数：<code>-n</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：文件名不存在。</li></ul></li><li><p>0x80000008 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt testcase.txt</code>。</li><li>文件系统：不关注文件系统。</li><li>文件内容：不关注输入内容。</li><li>错误说明：文件名存在多个。</li></ul></li><li><p>0x80000009 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt</code>。</li><li>文件系统：当前目录不存在名为 testcase.txt 的文件。</li><li>文件内容：不关注输入内容。</li><li>错误说明：文件不存在。</li></ul></li><li><p>0x8000000A 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt</code>。</li><li>文件系统：当前目录存在名为 testcase.txt 的文件夹，或当前目录存在名为 testcase.txt 的文件，但此文件被因被操作系统写有保护等原因不可读取。</li><li>文件内容：不关注输入内容。</li><li>错误说明：文件无法打开。</li></ul></li><li><p>0x8000000B 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt</code>。</li><li>文件系统：在获取文件大小后文件读取完成前修改文件，使文件大小变化。</li><li>文件内容：不关注输入内容。</li><li>错误说明：文件在读入时被修改。</li></ul></li><li><p>0x8000000C 测试样例</p><ul><li>命令行参数：<code>-n testcase.txt</code>。</li><li>文件系统：当前目录存在名为 testcase.txt 的文件，此文件可读。</li><li>文件内容：超过内存大小的若干字符。</li><li>错误说明：内存申请失败。</li></ul></li></ul><p>这部分需要比较琐碎，为此我们手工构造了 74 个测试用例，构造思路即为测试点名称，可望文生义：</p><pre class="highlight"><code class="c++"><span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">1</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">2</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">3</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">4</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">5</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagNotExistF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">6</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">7</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">8</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">9</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">10</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">11</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameNotExistF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">12</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">13</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">14</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">15</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">16</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">17</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FilenameDuplicateF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">18</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">19</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">20</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">21</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">22</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">23</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">37</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedG) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">38</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagUndefinedH) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">39</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">24</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">25</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">26</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">27</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">28</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">29</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorG) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">30</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorH) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">31</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamFormatErrorI) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">32</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(ParamNotExistA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">33</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamNotExistB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">34</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamNotExistC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">35</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(ParamNotExistD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">36</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">40</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">41</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">42</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">43</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">44</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">45</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictG) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">46</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictH) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">47</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictI) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">48</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictJ) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">49</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictSameA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">50</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictSameB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">51</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictSameC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">52</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictSameE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">53</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FlagConflictSameF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">54</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(FileNotExist) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">55</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(FileUnableOpen) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">56</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(CorrectA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">57</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">58</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">59</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">60</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">61</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">62</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectG) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">63</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectH) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">64</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectI) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">65</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectJ) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">66</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectK) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">67</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(CorrectL) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">68</span>); &#125;

<span class="hljs-built_in">TEST_METHOD</span>(RingA) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">69</span>, <span class="hljs-literal">true</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(RingB) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">70</span>, <span class="hljs-literal">true</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(RingC) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">71</span>, <span class="hljs-literal">true</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(RingD) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">72</span>, <span class="hljs-literal">true</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(RingE) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">73</span>, <span class="hljs-literal">true</span>); &#125;
<span class="hljs-built_in">TEST_METHOD</span>(RingF) &#123; <span class="hljs-built_in">cli_test_at</span>(<span class="hljs-number">74</span>, <span class="hljs-literal">true</span>); &#125;
</code></pre><p>与上文类似的，输入和评测方式存储在文件中，由 <code>cli_test_at</code> 函数调用：</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cli_test_at</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> index, <span class="hljs-type">bool</span> has_ring = <span class="hljs-literal">false</span>)</span>
</span>&#123;
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* result[<span class="hljs-number">20000</span>];
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* ring[] = &#123; <span class="hljs-string">&quot;Ab&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;cD&quot;</span>, <span class="hljs-string">&quot;DA&quot;</span> &#125;;
    <span class="hljs-type">static</span> <span class="hljs-type">char</span>* chain[] = &#123; <span class="hljs-string">&quot;Ab&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;cD&quot;</span>, <span class="hljs-string">&quot;DE&quot;</span> &#125;;
    filename = <span class="hljs-literal">nullptr</span>;
    param_h = <span class="hljs-type">param_t</span> = <span class="hljs-string">&#x27;\0&#x27;</span>;
    flag_n = flag_w = flag_m = flag_c = flag_h = <span class="hljs-type">flag_t</span> = flag_r = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">check_testcase</span>(index, <span class="hljs-string">&quot;clitest&quot;</span>);
    string base = <span class="hljs-string">&quot;../../cases/clitest/testcase&quot;</span> + <span class="hljs-built_in">to_string</span>(index);
    <span class="hljs-built_in">read_by_line</span>(base + <span class="hljs-string">&quot;.in&quot;</span>, in_content, in_len);
    <span class="hljs-built_in">read_by_line</span>(base + <span class="hljs-string">&quot;.config&quot;</span>, config_content, config_len);
    <span class="hljs-built_in">create_temp_file</span>(<span class="hljs-string">&quot;testcase.txt&quot;</span>, has_ring ? ring : chain, <span class="hljs-built_in">sizeof</span>(has_ring ? ring : chain) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*));
    <span class="hljs-built_in">cli_parse_check</span>(<span class="hljs-built_in">main</span>(in_len, in_content), config_content, config_len);
    <span class="hljs-built_in">remove_temp_file</span>(<span class="hljs-string">&quot;testcase.txt&quot;</span>);
    <span class="hljs-built_in">free_content</span>(in_content, in_len);
    <span class="hljs-built_in">free_content</span>(config_content, config_len);
    <span class="hljs-keyword">delete</span> in_content;
    <span class="hljs-keyword">delete</span> config_content;
&#125;
</code></pre><h3 id="功能测试"><a class="markdownIt-Anchor" href="#功能测试"></a> 功能测试</h3><blockquote><p>这并不是作业里面要求的问题，但我们认为有必要对其进行说明。（0’）</p></blockquote><p>我们认为，仅靠手工构造的测试用例进行单元测试并不能很好的保证程序的正确性，为此我们开发了测试数据生成器，并实现了对拍机，见代码仓库 utils 目录下。</p><p>测试数据生成器的接口如下：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">length, no_same, self_cycle_max, no_cycle, confuse</span>):
    <span class="hljs-string">&quot;&quot;&quot;
    :param length: 输入长度
    :param no_same: 不允许完全一样的单词
    :param self_cycle_max: 自环的数量上限
    :param no_cycle: 不允许输入单词环
    :param confuse: 混淆输出
    :return:
    &quot;&quot;&quot;</span>
</code></pre><p>基于上述接口，我们采用多种不同的规则生成测试数据：</p><ul><li><p>长度方面，我们考虑了以下情况：</p><ul><li>长度为 1 的数据，测试边界值。</li><li>长度为 5 的数据，测试小数据。</li><li>长度为 100 的数据，测试中等数据。</li><li>长度为 1000 的数据，测试较大数据（不存在 -r 时）。</li></ul></li><li><p>环路方面，我们考虑了以下情况：</p><ul><li>一个字母上至多存在 1、2、4、5 个自环。</li><li>除自环外，存在/不存在环路。</li></ul></li></ul><p>我们最终选择生成七类数据，每一类生成 100 个测试点：</p><pre class="highlight"><code class="python">count = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_no_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=<span class="hljs-number">1</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">1</span>, no_cycle=<span class="hljs-literal">True</span>, confuse=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_no_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=i // <span class="hljs-number">5</span> + <span class="hljs-number">1</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">1</span>, no_cycle=<span class="hljs-literal">True</span>, confuse=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_no_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=<span class="hljs-number">100</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">1</span>, no_cycle=<span class="hljs-literal">True</span>, confuse=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_no_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=<span class="hljs-number">1000</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">1</span>, no_cycle=<span class="hljs-literal">True</span>, confuse=<span class="hljs-literal">False</span>))

count = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=<span class="hljs-number">1</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">2</span>, no_cycle=<span class="hljs-literal">False</span>, confuse=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=i // <span class="hljs-number">5</span> + <span class="hljs-number">1</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">4</span>, no_cycle=<span class="hljs-literal">False</span>, confuse=<span class="hljs-literal">False</span>))

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&quot;data_cycle_<span class="hljs-subst">&#123;count&#125;</span>.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:
        f.write(generate(length=<span class="hljs-number">100</span>, no_same=<span class="hljs-literal">False</span>, self_cycle_max=<span class="hljs-number">5</span>, no_cycle=<span class="hljs-literal">False</span>, confuse=<span class="hljs-literal">False</span>))
</code></pre><p>在测试过程中，我们发现了自身的 Bug 和参与对拍组的 Bug，需要说明的是，参与对拍的双方均已经过单元测试。</p><h3 id="性能改进"><a class="markdownIt-Anchor" href="#性能改进"></a> 性能改进</h3><blockquote><p>计算模块接口部分的性能改进。记录在改进计算模块性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（由 VS 2019 的性能分析工具自动生成），并展示你程序中消耗最大的函数。（3’）</p></blockquote><p>我们在设计阶段考虑了以下性能优化：</p><ul><li>使用 fread 读入数据，减少系统调用次数以优化性能。</li><li>使用邻接矩阵存图，以加速查询。</li><li>缓存/维护包括单词长度，单词链单词数，单词链字母数等的信息，以加速查询。</li></ul><p>此外，在测试过程中，我们发现我们的程序面对存在较多自环的数据性能较差，例如对于以下数据：</p><pre class="highlight"><code class="plain">aa axa aya aza ab axb ac axc ba bxa bb bxb byb bzb bc bxc ca cxa cb cxb cc cxc cyc czc
</code></pre><p>使用 VS 2019 的性能分析工具分析如下，可以发现大量时间被用于 <code>gen_chain_dfs</code>：</p><img src="/assets/images/buaa-se/hw3/perf-1.jpg" width="80%"><p>添加“合并自环优化”后，使用 VS 2019 的性能分析工具分析如下：</p><img src="/assets/images/buaa-se/hw3/perf-2.jpg" width="80%"><p>这个过程包括调试在内花费了大约 120 分钟时间。</p><p>然而，在存在 -r 的情况下，最长单词链问题实质上是 NPC 的有向有环图最长路径问题，我们总可以构造数据将算法卡出指数复杂度，例如使用以下数据：</p><pre class="highlight"><code class="plain">aa ab ac ad ae af ba bb bc bd be bf ca cb cc cd ce cf da db dc dd de df ea eb ec ed ee ef
</code></pre><p>使用 VS 2019 的性能分析工具分析如下，可以发现大量时间仍然被用于 <code>gen_chain_dfs</code>：</p><img src="/assets/images/buaa-se/hw3/perf-3.jpg" width="80%"><h3 id="松耦合测试"><a class="markdownIt-Anchor" href="#松耦合测试"></a> 松耦合测试</h3><blockquote><p>在博客中指明合作小组两位同学的学号，分析两组不同的模块合并之后出现的问题，为何会出现这样的问题，以及是如何根据反馈改进自己模块的。（10’）</p></blockquote><p>合作小组两位同学的学号是：</p><ul><li>Roife：19373189</li><li>Yip Coekjan：19373372</li></ul><p>合作小组的模块使用 C# 开发，为此我们需要额外安装以下内容：</p><img src="/assets/images/buaa-se/hw3/vs.jpg" width="80%"><p>在 C++ 中，我们可以通过使用下面的方式引入 DLL：</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _DEBUG</span>
    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;../x64/Debug/core.lib&quot;</span>)</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;../x64/Release/core.lib&quot;</span>)</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>但 C# 生成的 DLL 不附带 .lib 文件，为此需要修改引入 DLL 的方式，此外合作小组的接口放入了命名空间，因此需要套一层壳：</p><img src="/assets/images/buaa-se/hw3/shell.jpg"><p>最后，需要进行以下两项设置和一处更改，即可跑通：</p><ul><li><p>调整<strong>项目属性 - 配置属性 - 高级 - 公共语言运行时支持</strong>为公共语言运行时支持（clr）。</p></li><li><p>调整<strong>项目属性 - 配置属性 - C/C++ - 语言 - 符合模式</strong>为否（permissive）。</p></li><li><p>因我们和合作小组的内存管理方式不同，我们需要更改内存分配方式，全部内存由调用者分配，既将 result 指针数组中所有的指针指向已分配的空间，相关代码如下：</p><pre class="highlight"><code class="c++"><span class="hljs-type">static</span> <span class="hljs-type">char</span> space[<span class="hljs-number">20000</span>][<span class="hljs-number">1024</span>];
<span class="hljs-type">static</span> <span class="hljs-type">char</span>* result[<span class="hljs-number">20005</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++)
&#123;
    result[i] = space[i];
&#125;
</code></pre></li></ul><p>此外，笔者的 Visual Studio 是 2019 版本，合作小组和队友的 Visual Studio 都是 2022 版本，因此在互换 DLL 的过程中存在（疑似 .NET）兼容问题，笔者本地始终无法跑通，队友本地则可以跑通。</p><h2 id="合约编程"><a class="markdownIt-Anchor" href="#合约编程"></a> 合约编程</h2><blockquote><p>看 Design by Contract，Code Contract 的内容，并描述这些做法的优缺点，说明你是如何把它们融入结对作业中的。（5’）</p><ul><li><a href="http://en.wikipedia.org/wiki/Design_by_contract">http://en.wikipedia.org/wiki/Design_by_contract</a></li><li><a href="http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx">http://msdn.microsoft.com/en-us/devlabs/dd491992.aspx</a></li></ul><p>契约式设计（Design by Contract），是一种设计计算机软件的方法。这种方法要求软件设计者为软件组件定义正式的，精确的并且可验证的接口，这样，为传统的抽象数据类型又增加了先验条件、后验条件和不变式。这种方法的名字里用到的“契约”是一种比喻，因为它和商业契约的情况有点类似。</p><p>因为“Design by Contract”是属于 Eiffel Software 的注册商标，很多开发人员用契约式编程（Programming by Contract），契约编程（Contract Programming），或者契约优先式开发（Contract-First development）来指代这种方法。微软也采用这种设计方法，称为代码合约（Code Contracts）。</p></blockquote><p>个人理解，契约式设计就是通过语言层面上的参数检查和结果检查，实现程序在运行时只要不报错就是正确的。</p><ul><li><p>优点：</p><ul><li>要求程序员确定“先验条件”、“后验条件”和“不变式”，在这个过程中程序员可能发现代码的 Bug。</li><li>通过“先验条件”、“后验条件”和“不变式”，Bug 的定位变得容易。</li><li>可以基于“先验条件”、“后验条件”和“不变式”的指导进行单元测试。</li></ul></li><li><p>缺点：</p><ul><li>个人理解，契约式设计的检查无法完全在编译过程中完成，因此总有些工作需要在运行时处理，导致程序性能下降。</li><li>程序员在确定“先验条件”、“后验条件”和“不变式”上的开销是否和契约式设计的回报（如代码质量）匹配，尤其是在存在单元测试，代码复审等保证代码质量的其它手段的情况下。</li></ul></li></ul><p>我们并没有设计接口，原因见“接口设计”部分，不再赘述。我们也没有确定“先验条件”、“后验条件”和“不变式”，而是通过单元测试，功能测试，代码复审等手段保证代码质量。</p><h2 id="结对过程"><a class="markdownIt-Anchor" href="#结对过程"></a> 结对过程</h2><blockquote><p>描述结对过程，提供两人的结对图像资料（比如 Live Share 的截图）。关于如何远程进行结对参见作业最后的注意事项。（1’）</p></blockquote><p>我们在新主楼 F 座三层或者四层线下结对，如下图（<s>看上去我该减肥了</s>）：</p><img src="/assets/images/buaa-se/hw3/pic.jpg" width="80%"><p>此外恕我们眼拙，并没有在作业最后找到“注意事项”，作业的最后是包括“PSP 2.1 表格”和“参数约定”的附录，此外页面搜索结果如下：</p><img src="/assets/images/buaa-se/hw3/requirement.jpg"><h2 id="优缺点分析"><a class="markdownIt-Anchor" href="#优缺点分析"></a> 优缺点分析</h2><blockquote><p>看教科书和其它参考书，网站中关于结对编程的章节，例如：<a href="http://www.cnblogs.com/xinz/archive/2011/08/07/2130332.html">http://www.cnblogs.com/xinz/archive/2011/08/07/2130332.html</a> ，说明结对编程的优点和缺点。同时描述结对的每一个人的优点和缺点在哪里（要列出至少三个优点和一个缺点）。（5’）</p></blockquote><p>结对编程的优点：</p><ul><li>结对编程让两个人所写的代码不断地处于“复审”的过程，可以及时地发现问题和解决问题，避免把问题拖到后面的阶段。</li><li>结对编程时每个人的一举一动都在别人的视线之内，有利于使得程序员更认真地工作。</li></ul><p>结对编程的缺点：</p><ul><li>启动成本高，需要磨合（当然这和结对编程的两个人有关）。</li><li>个人认为存在以下不等式，因此结对编程不见得优于两人分工。</li></ul><blockquote><p>单人编程效率 &lt; 结对编程效率 &lt; 双人分工编程效率</p></blockquote><p>杰对编程的优点：</p><ul><li>可以找到靠谱的队友。</li><li>有结对编程的理论指导。</li><li>罗杰老师足够负责，群里问问题能有比较及时的回复。</li></ul><p>杰对编程的缺点：</p><ul><li>接口设计问题，这个问题前面已经说过了，不再赘述。</li><li>指导书笔误过多，建议邀请各位任课老师和助教“代码复审”。</li><li>没有定量的测试标准，只有定性的“不会强调处理大规模数据的性能”，什么叫“大规模数据”，能否给出形式化定义。</li><li>性能测试部分不合理，原因如下：<ul><li>循环会增加开销，我把 <code>for i in range(26)</code> 手动展开成 26 个过程，这样算不算性能优化，这样有工程性吗？</li><li>函数调用会增加开销，我把不涉及递归的部分全部写在一个函数，这样算不算性能优化，这样有工程性吗？</li><li>汇编的执行效率比高级语言高，我到处内联汇编，这样算不算性能优化，这样有工程性吗？</li><li>单词链问题是 NPC 问题，总可以构造数据卡出指数复杂度，优化只是面向特定数据优化，如何处理甲就做了一个优化且性能测试刚好测了，乙做了十个优化但性能测试都没测到的情况？</li><li>测试结果依赖操作系统当前环境，不可重现，相比之下无论是求导还是编译，无论执行多少次，结果长度/指令运行代价都是不变的，也就不会存在运行一次甲比乙快，再运行一次乙比甲快，但计时竞速如何避免这一问题？</li><li>C++ 是编译型语言而 C# 是编译解释型语言，二者天生存在常数差异，如何公平化使用 C++ 的同学和使用 C# 的同学？</li></ul></li><li>只有罗杰老师足够负责，群里问问题能有比较及时的回复。</li></ul><p>自己的优点：</p><ul><li>OO 狼人出身，熟悉造数据搭评测机对拍一条龙。</li><li>比较细致，善于发现代码中的问题。</li><li>熟悉写法上的常数优化（<s>受过数据结构大作业的毒打</s>）。</li></ul><p>自己的缺点：</p><ul><li>这个智障的 Visual Studio 是 2019 版本，互换 DLL 的时候存在兼容性问题，浪费了不少时间。</li><li>JetBrains 全家桶用户，没用过 Visual Studio。</li><li>不太懂算法，尤其比较虚 dp。</li><li>用 C++ 写过算法，但没写过有一定规模的项目。</li><li>不爱写文档和注释，Markdown 风格鬼畜，得改。</li></ul><blockquote><p>迁博客时注：Markdown 风格已经改麻了，早点用上 Markdown Lint 也不至于有今天。</p></blockquote><p>队友的优点：</p><ul><li>OO 狼人出身，熟悉造数据搭评测机对拍一条龙。</li><li>比较细致，善于发现代码中的问题。</li><li>编译是 C++ 写的，更加熟悉 C++。</li><li>熟悉 Python，熟悉 GUI 绘制。</li></ul><p>队友的缺点：</p><ul><li>JetBrains 全家桶用户，没用过 Visual Studio。</li><li>不太懂算法，尤其比较虚 dp。</li></ul><p>其它感受：</p><p>个人认为自己和 Dr-Bluemond 的定位比较重叠，于是就会出现下面的情况：</p><ul><li>擅长/熟悉的工作一个人就能完成好。</li><li>不擅长/不熟悉的工作两个人做效果也中规中矩。</li></ul><p>我们两个人都比较熟悉测试，于是我们合作的下限就会比较高，代码质量有基本的保障；我们两个人都不太擅长算法，于是我们合作的上限就比较有限，至少在有限的时间内难以搞出 SCC + DP 的性能优化。</p><p>此外由于我们的定位比较重叠，合作进行的过于顺利，似乎少了一些磨合上的锻炼？</p><h2 id="实际耗时"><a class="markdownIt-Anchor" href="#实际耗时"></a> 实际耗时</h2><blockquote><p>在你实现完程序之后，在附录提供的 PSP 表格记录下你在程序的各个模块上实际花费的时间。（0.5’）</p></blockquote><table><thead><tr><th style="text-align:left">PSP 2.1</th><th style="text-align:center">Personal Software Process Stages</th><th style="text-align:center">实际耗时（分钟）</th></tr></thead><tbody><tr><td style="text-align:left">Planning</td><td style="text-align:center">计划</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">      Estimate</td><td style="text-align:center">估计这个任务需要多少时间</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">Development</td><td style="text-align:center">开发</td><td style="text-align:center">1930</td></tr><tr><td style="text-align:left">      Analysis</td><td style="text-align:center">需求分析（包括学习新技术）</td><td style="text-align:center">180</td></tr><tr><td style="text-align:left">      Design Spec</td><td style="text-align:center">生成设计文档</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">      Design Review</td><td style="text-align:center">设计复审（和同事审核设计文档）</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">      Coding Standard</td><td style="text-align:center">代码规范（为目前的开发制定合适的规范）</td><td style="text-align:center">20</td></tr><tr><td style="text-align:left">      Design</td><td style="text-align:center">具体设计</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">      Coding</td><td style="text-align:center">具体编码</td><td style="text-align:center">720</td></tr><tr><td style="text-align:left">      Code Review</td><td style="text-align:center">代码复审</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">      Test</td><td style="text-align:center">测试（自我测试，修改代码，提交修改）</td><td style="text-align:center">800</td></tr><tr><td style="text-align:left">Reporting</td><td style="text-align:center">报告</td><td style="text-align:center">150</td></tr><tr><td style="text-align:left">      Test Report</td><td style="text-align:center">测试报告</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left">      Size Measurement</td><td style="text-align:center">计算工作量</td><td style="text-align:center">30</td></tr><tr><td style="text-align:left">      Postmortem &amp; Process Improvement Plan</td><td style="text-align:center">事后总结, 并提出过程改进计划</td><td style="text-align:center">60</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">合计</td><td style="text-align:center">2090</td></tr></tbody></table><h2 id="致谢与建议"><a class="markdownIt-Anchor" href="#致谢与建议"></a> 致谢与建议</h2><p>在结对编程过程中，需要对以下人物或产品表示感谢：</p><ul><li>感谢 Dr-Bluemond 和我共同完成结对编程作业。</li><li>感谢 Roife 和 Yip Coekjan 在互换 DLL 过程中提供的指导和帮助。</li><li>感谢 CSDN，得益于这里丰富的资料，在踩坑过程中我的抗压能力得到了提升。</li><li>感谢<strong>罗杰</strong>老师，即使结对编程作业的时间已经过半，您还在不辞辛劳地多次修正指导书，令人泪目。</li><li>感谢<strong>任健</strong>老师和<strong>助教</strong>们，您们通过“努力”，自始至终有效地避免了课程组对于同学们的问题回应不一致的情况。</li><li>感谢<strong>我的女朋友</strong>，正因为她根本不存在，我得以有更多的时间和精力用于结对编程。</li></ul><p>对结对编程，有以下建议：</p><ul><li>打铁还需自身硬，建议课程组公开全部标程供同学们 Hack。</li><li>本次结对编程的头一周基本都在扯需求改指导书，建议明年提前一周开放结对编程，这样同学们就有两周时间可以真正干活了。</li><li>建议不要要求同学在博客中暴露自己或他人的<strong>学号</strong>和<strong>真实姓名</strong>，这不是在校内，请<strong>对同学们的信息负责</strong>。</li><li>建议不要要求同学在博客中暴露自己或他人的<strong>学号</strong>和<strong>真实姓名</strong>，这不是在校内，请<strong>对同学们的信息负责</strong>。</li><li>建议不要要求同学在博客中暴露自己或他人的<strong>学号</strong>和<strong>真实姓名</strong>，这不是在校内，请<strong>对同学们的信息负责</strong>。</li></ul></div><div>Word count: 10.7k</div><div>Reading time: 42min</div><div><div><a href="/archive/2022/04/1">Created 2022-04-04T10:26:44.000Z</a></div></div><div><div><a href="/archive/2022/04/1">Last Modified 2022-04-04T10:26:44.000Z</a></div></div><div><br><br></div></div></content><div><br></div><footer>Copyright © 2021-2023 Chenrt Blog</footer></noscript><div id="app"></div></body></html>