<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Chenrt"><meta name="keywords" content="Chenrt, @Chenrt, Chenrt Blog, 计算机, 网络安全, 博客, 个人网站"><meta name="description" content="Chenrt 的个人博客"><meta name="generator" content="Hexo"><link rel="icon" href="/favicon.svg"><title>Chenrt の 小窝 - 数据结构大作业算法实现总结</title><script defer="defer" src="/js/chunk-vendors.js"></script><script defer="defer" src="/js/app.js"></script><link href="/css/chunk-vendors.css" rel="stylesheet"><link href="/css/app.css" rel="stylesheet"></head><body><noscript><header><nav><a href="/">Home</a></nav><nav><a href="/blogs/1">Blogs</a></nav><nav><a href="/category">Categories</a></nav><nav><a href="/tag">Tags</a></nav><nav><a href="/archive">Archives</a></nav><nav><a href="/about">About</a></nav><nav><a href="/apis">Api</a></nav></header><div><br></div><content><div><a href="/blog/b552ad49e5bf"><h1>数据结构大作业算法实现总结</h1></a><div><div><div><a href="/category/Buaa/1">Buaa</a></div><div><a href="/category/Buaa/DSP/1">DSP</a></div></div></div><div><div><div><a href="/tag/Algorithm/1">Algorithm</a></div><div><a href="/tag/C/1">C</a></div></div></div><div><p>[早期博客补档] | 以 2020 年数据结构大作业为例，本部分主要包括问题与算法实现。</p><span id="more"></span><p>菜鸡才疏学浅，在榜一坐了大半个学期，快截止的时候被郭佬干到榜二了。完整代码太丑，就不发了。</p><h2 id="问题简述"><a class="markdownIt-Anchor" href="#问题简述"></a> 问题简述</h2><p>我们知道每位作者都有自己的文风和用词习惯，有研究根据这个特性，研究《红楼梦》前八十回和后四十回是否是由曹雪芹一人所作。编程实现一个基于词频的文本相关性分析程序，实现对两个文本文件的相关性分析。其分析方法如下：</p><ul><li><p>首先分别统计所提供的两个文本文件中单词出现频率（即出现次数）。为了提高算法的准确性，在此只统计字典中出现且不为停用词（stop-word）的单词。单词为仅由字母组成的字符序列，包含大写字母的单词应将大写字母转换为小写字母后进行词频统计。</p><p>所提供的字典“dictionary.txt”文件和英文停用词表“stopwords.txt”文件（只包含单词，不含其解释，且已按字典序排序）可在课程下载区获得。注意：实际评测时字典要比所提供的字典要大。</p><blockquote><p>说明：在自然语言处理中，停用词（stop-word）指的是文本分析时不会提供额外语义信息的词的列表，如英文单词 a、an、he、you 等就是停用词。</p></blockquote></li><li><p>分别取两个文本文件中出现频率最高的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词（按单词出现频率进行排序，频率相同的单词按字典序，然后取前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词。若单词数不足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，则按实际数目）。假设两个文本文件中出现频率最高的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个单词相同，分别计算这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个单词在两个文本的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词中的频率占比：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mi>r</mi><mi>o</mi><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mi>F</mi><mi>r</mi><mi>e</mi><msubsup><mi>q</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>F</mi><mi>r</mi><mi>e</mi><msub><mi>q</mi><mi>j</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">Pro=\frac{\sum_{i=1}^{M}Freq&#x27;_i}{\sum_{j=1}^{N}Freq_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.97799em;vertical-align:-1.3070490000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.670941em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897100000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3070490000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mi>e</mi><msubsup><mi>q</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">Freq&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span> 为两个文本文件中词频最高的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词中共有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个单词中每个单词在某一文本中出现的频率；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mi>e</mi><msub><mi>q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Freq_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 为某一文本中前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个词频最高的单词的频率（若不足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，则按实际数目）。</p></li><li><p>最后计算两个文本的相关度。假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Pro_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Pro_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别为两个文本文件中词频最高的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词中共有词的频率占比，则两个文本文件的相关度计算公式为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mo>=</mo><mfrac><mrow><mi>min</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>P</mi><mi>r</mi><msub><mi>o</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">Sim=\frac{\min{(Pro_1,Pro_2)}}{\max{(Pro_1,Pro_2)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mop">min</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop">max</span></span></span></span> 分别计算两个值中的最小值和最大值。</p></li></ul><h3 id="输入形式"><a class="markdownIt-Anchor" href="#输入形式"></a> 输入形式</h3><p>首先从标准输入中读入一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，作为需要统计分析的两个文本文件的高频单词个数。</p><p>根据当前目录下字典文件“dictionary.txt”和停用词文件“stopwords.txt”，打开当前目录下文件“article1.txt”和“article2.txt”，按上面要求对两个文件进行相关性分析。</p><h3 id="输出形式"><a class="markdownIt-Anchor" href="#输出形式"></a> 输出形式</h3><p>在屏幕上输出相关度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span></span></span></span> 值，小数点后保留五位，同时将相关度值和两个文本文件中出现频率最高的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词及出现频率按频率由大至小序输出到当前目录下“results.txt”中。文件输出时要求如下：</p><ul><li>先输出计算得到的相关度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span></span></span></span> 值（小数点后保留五位）。</li><li>输出一个空行。</li><li>输出第一个文本文件的单词频率。</li><li>输出一个空行。</li><li>输出第二个文本文件的单词频率。</li></ul><p>输出单词及频率时每行输出一个单词及其出现的频率，中间由一个空格分隔，每个单词其频率后无空格，直接为回车，单词频率相同时，按字典序输出单词。</p><h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2><h3 id="基于数组的查找"><a class="markdownIt-Anchor" href="#基于数组的查找"></a> 基于数组的查找</h3><ul><li>读入字典和停词并存入列表（已保证字典序）。</li><li>读入文章 1 中的单词，对于每个单词，在停词列表中二分查找，如果没有查找到则在字典中二分查找，如果找到则记录此单词在文章 1 中出现一次。</li><li>读入文章 2 中的单词，对于每个单词，在停词列表中二分查找，如果没有查找到则在字典中二分查找，如果找到则记录此单词在文章 2 中出现一次。</li><li>遍历字典列表，找出所有文章 1 中出现的单词及次数和所有文章 2 中出现的单词及次数（见统计部分）。</li><li>按题目要求寻找在两篇文章都出现的单词并计算相似度，输出相似度与两个文件中的单词频率（见统计部分）。</li></ul><pre class="highlight"><code class="c">in = fopen(<span class="hljs-string">&quot;dictionary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (~<span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%s&quot;</span>, dict[topdict++].s));
fclose(in);
in = fopen(<span class="hljs-string">&quot;stopwords.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (~<span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%s&quot;</span>, stop[topstop++].s));
fclose(in);
which = <span class="hljs-number">0</span>, in = fopen(<span class="hljs-string">&quot;article1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (read()) <span class="hljs-keyword">if</span> (!change(stop, <span class="hljs-number">0</span>)) change(dict, <span class="hljs-number">1</span>);
fclose(in);
which = <span class="hljs-number">1</span>, in = fopen(<span class="hljs-string">&quot;article2.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (read()) <span class="hljs-keyword">if</span> (!change(stop, <span class="hljs-number">0</span>)) change(dict, <span class="hljs-number">1</span>);
fclose(in);

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; topdict; ++i) &#123;
    <span class="hljs-keyword">if</span> (dict[i].art1) article1[topart1++] = dict[i];
    <span class="hljs-keyword">if</span> (dict[i].art2) article2[topart2++] = dict[i];
&#125;

<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
<span class="hljs-keyword">if</span> (n &gt; topart1) n = topart1;
<span class="hljs-keyword">if</span> (n &gt; topart2) n = topart2;
</code></pre><h3 id="基于非线性结构的查找"><a class="markdownIt-Anchor" href="#基于非线性结构的查找"></a> 基于非线性结构的查找</h3><p>非线性结构包括二叉树、Trie 和 Hash 表（理论上还包括 B 树和 B+ 树等，笔者没有进行尝试，性能应该优于二叉树，不如 Trie 和 Hash 表），在处理过程上大同小异：</p><ul><li>构造一个上述结构，每个节点是一个单词，额外维护其在文章 1 和文章 2 中的出现次数。</li><li>读入文章 1 中的单词并加入结构，更新其在文章 1 的出现次数。</li><li>读入文章 2 中的单词并加入结构，更新其在文章 2 的出现次数。</li><li>读入停词，对于每个单词，在结构中查找并删除。</li><li>读入字典，对于每个单词，如果在结构中查找到，则：<ul><li>如果其在文章 1 的出现次数非 0，就将其存入所有文章 1 中出现的单词及次数的集合（见统计部分）。</li><li>如果其在文章 2 的出现次数非 0，就将其存入所有文章 2 中出现的单词及次数的集合（见统计部分）。</li></ul></li><li>按题目要求寻找在两篇文章都出现的单词并计算相似度，输出相似度与两个文件中的单词频率（见统计部分）。</li></ul><p>由于文章中单词的数量远小于字典中单词的数量，在文章查字典单词比在字典查文章单词快得多，这也是基于非线性结构的做法快于基于数组的做法的主要原因；在不同非线性结构的性能方面：</p><ul><li>对于二叉树，由于数据没有经过特别构造，普通二叉树和平衡二叉树（采用红黑树进行对比测试）性能差别不大。</li><li>由于二叉树以单词为单位、复杂度与单词数量和长度（比较的开销）有关，其性能不如以字符为单位、复杂度只与单词长度有关的 Trie 和不基于比较的 Hash 表。</li><li>经测试，Trie 的性能略微优于 Hash 表（拉链法处理冲突，在选择合适的 Hash 函数后冲突极少），这可能是因为 Trie 在发现前缀不匹配后直接停止比较，而 Hash 表需要读完整个单词计算 Hash，在访存上不如 Trie 友好。</li></ul><pre class="highlight"><code class="c">in = fopen(<span class="hljs-string">&quot;article1.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (read()) ins(<span class="hljs-number">0</span>);
fclose(in);
in = fopen(<span class="hljs-string">&quot;article2.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (read()) ins(<span class="hljs-number">1</span>);
fclose(in);
in = fopen(<span class="hljs-string">&quot;stopwords.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (~<span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%s&quot;</span>, newword)) del();
fclose(in);
in = fopen(<span class="hljs-string">&quot;dictionary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
<span class="hljs-keyword">while</span> (~<span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%s&quot;</span>, newword)) find();
fclose(in);

<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
<span class="hljs-keyword">if</span> (n &gt; topart1) n = topart1;
<span class="hljs-keyword">if</span> (n &gt; topart2) n = topart2;
</code></pre><h3 id="基于数组的统计"><a class="markdownIt-Anchor" href="#基于数组的统计"></a> 基于数组的统计</h3><ul><li>将文章 1 中出现的单词及次数存入列表 1，将文章 2 中出现的单词及次数存入列表 2；复制列表 1 得列表 3、复制列表 2 得列表 4。</li><li>对列表 1 和列表 2，按次数为第一关键字降序，单词字典序为第二关键字升序排序；对列表 3 和列表 4，按单词字典序升序排序。</li><li>双指针遍历列表 3 和列表 4，统计在两篇文章中都出现的单词的频率和，按题目要求计算相似度并输出。</li><li>分别输出列表 1 和列表 2 中的前若干项到对应文件。</li></ul><pre class="highlight"><code class="c">qsort(article1, topart1, <span class="hljs-keyword">sizeof</span>(word), cmp1);
qsort(article2, topart2, <span class="hljs-keyword">sizeof</span>(word), cmp1);
<span class="hljs-type">int</span> same1 = <span class="hljs-number">0</span>, same2 = <span class="hljs-number">0</span>, con1 = <span class="hljs-number">0</span>, con2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
    copy1[i] = article1[i], con1 += article1[i].num;
    copy2[i] = article2[i], con2 += article2[i].num;
&#125;
qsort(copy1, n, <span class="hljs-keyword">sizeof</span>(word), cmp2);
qsort(copy2, n, <span class="hljs-keyword">sizeof</span>(word), cmp2);
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cmp, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; j &lt; n;) &#123;
    cmp = <span class="hljs-built_in">strcmp</span>(copy1[i].s, copy2[j].s);
    <span class="hljs-keyword">if</span> (!cmp) &#123;
        same1 += copy1[i].num;
        same2 += copy2[j].num;
        ++i, ++j;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;
        ++j;
    &#125; <span class="hljs-keyword">else</span> &#123;
        ++i;
    &#125;
&#125;
</code></pre><h3 id="基于-hash-的统计"><a class="markdownIt-Anchor" href="#基于-hash-的统计"></a> 基于 Hash 的统计</h3><ul><li>维护两个 Hash 表，分别存储文章 1 中出现的单词及次数和文章 2 中出现的单词及次数，Hash 函数为单词的出现次数，拉链法处理冲突（字典的有序性保证了单词按字典序加入，从而保证了输出时单词字典序为第二关键字升序）。</li><li>按次数从大到小遍历文章 1 的 Hash 表的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词，对于每个单词记录其出现次数；按次数从大到小遍历文章 2 的 Hash 表的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词，对每个在文章 1 中出现的单词更新其在两篇文章中的频率和，按题目要求计算相似度并输出。</li><li>按次数从大到小遍历文章 1 和文章 2 的 Hash 表，输出单词和频率到对应文件。</li></ul><p>记录单词及出现次数和查找单词可以如下高效实现：</p><ul><li>每个单词只存储一份，以引用（指针）的方式访问这个单词，即单词和地址（或下标）是一一映射。因此实际上只要记录地址（或下标）和对应的出现次数。</li><li>构造一个 vis 数组，遍历文章 1 的 Hash 表的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词时，对于每个单词，在 vis 数组中单词下标的位置存储其出现次数；遍历文章 2 的 Hash 表的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个单词时，在 vis 数组中读取单词下标的位置，如果其非 0 则表示其同时出现在文章 1 中，且出现次数即 vis 数组中相应位置的值。</li></ul><pre class="highlight"><code class="c"><span class="hljs-keyword">for</span> (i = top1, k = <span class="hljs-number">0</span>; i &amp;&amp; k &lt; n; --i) &#123;
    <span class="hljs-keyword">for</span> (j = fst1[i]; j &amp;&amp; k &lt; n; j = nxt1[j]) &#123;
        con1 += i, k++;
        vis[j] = i;
    &#125;
&#125;
<span class="hljs-keyword">for</span> (i = top2, k = <span class="hljs-number">0</span>; i &amp;&amp; k &lt; n; --i) &#123;
    <span class="hljs-keyword">for</span> (j = fst2[i]; j &amp;&amp; k &lt; n; j = nxt2[j]) &#123;
        con2 += i, k++;
        <span class="hljs-keyword">if</span> (vis[j]) &#123;
            same1 += vis[j];
            same2 += i;
        &#125;
    &#125;
&#125;
</code></pre><p>容易发现，上述 Hash 表实际上可以理解为邻接表并采用链式前向星进行实现。由于链式前向星只维护了链表的头指针，遍历顺序是挂链顺序的逆序，单词按字典序加入就无法按字典序遍历，为了按字典序遍历有两种处理：</p><ul><li><p>维护尾指针：</p><p>既然链式前向星只维护链表的头指针，所以只能在头部插入节点导致逆序，只要额外维护一个尾指针在尾部插入节点，就没有逆序的问题了。这种处理会引入额外的空间开销。</p></li><li><p>强行逆序挂链：</p><ul><li>对于字典树和二叉树，结构本身包含了顺序，可以不依赖字典提供的字典序，只将字典用于筛选。用字典筛选后按字典序从大到小的顺序进行遍历，即可按反字典序加入链式前向星，链式前向星遍历时就是字典序了。</li><li>对于 Hash 表，结构本身不存在顺序，筛选出来排序开销较大，需要使用字典提供的字典序，自然想到“反向读取字典”。由于反向读字典时，会出现从后往前找到一个单词，再从前往后算这个单词的 Hash 的问题，干脆直接“反向理解单词”。即无论是文章、停词还是字典都从后往前读，Hash 也从后往前算（<s>欧阳锋直呼内行</s>）。</li></ul></li></ul><p>经笔者测试，基于 Hash 的统计性能优于基于数组的统计；在基于 Hash 的统计中，几种处理方式性能差别不大。</p></div><div>Word count: 3.3k</div><div>Reading time: 13min</div><div><div><a href="/archive/2020/07/1">Created 2020-07-14T03:10:43.000Z</a></div></div><div><div><a href="/archive/2020/07/1">Last Modified 2020-07-14T03:10:43.000Z</a></div></div><div><br><br></div></div></content><div><br></div><footer>Copyright © 2020-2023 Chenrt Blog</footer></noscript><div id="app"></div></body></html>