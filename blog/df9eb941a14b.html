<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Chenrt"><meta name="keywords" content="Chenrt, @Chenrt, Chenrt Blog, 计算机, 网络安全, 博客, 个人网站"><meta name="description" content="Chenrt 的个人博客"><meta name="generator" content="Hexo"><link rel="icon" href="/favicon.svg"><title>Chenrt の 小窝 - 软件工程第四次博客作业 | 杰后余生</title><script defer="defer" src="/js/chunk-vendors.js"></script><script defer="defer" src="/js/app.js"></script><link href="/css/chunk-vendors.css" rel="stylesheet"><link href="/css/app.css" rel="stylesheet"></head><body><noscript><header><nav><a href="/">Home</a></nav><nav><a href="/blogs/1">Blogs</a></nav><nav><a href="/category">Categories</a></nav><nav><a href="/tag">Tags</a></nav><nav><a href="/archive">Archives</a></nav><nav><a href="/about">About</a></nav><nav><a href="/apis">Api</a></nav></header><div><br></div><content><div><a href="/blog/df9eb941a14b"><h1>软件工程第四次博客作业 | 杰后余生</h1></a><div><div><div><a href="/category/Buaa/1">Buaa</a></div><div><a href="/category/Buaa/SE/1">SE</a></div></div></div><div><div><div><a href="/tag/Summary/1">Summary</a></div></div></div><div><p>[迁移自博客园] | BUAA 2021-2022 Software Engineering Homework 4</p><span id="more"></span><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:left">这个作业属于哪个课程</td><td style="text-align:left"><a href="https://bbs.csdn.net/forums/BH-SE">软件工程</a></td></tr><tr><td style="text-align:left">这个作业的要求在哪里</td><td style="text-align:left"><a href="https://bbs.csdn.net/topics/607080413">个人作业-提问回顾与个人总结</a></td></tr><tr><td style="text-align:left">我在这个课程的目标是</td><td style="text-align:left">提高工程能力，练习团队开发</td></tr><tr><td style="text-align:left">这个作业在哪个具体方面帮助我实现目标</td><td style="text-align:left">回顾疑问、课程总结与反思</td></tr></tbody></table><h2 id="疑问与解答"><a class="markdownIt-Anchor" href="#疑问与解答"></a> 疑问与解答</h2><blockquote><p>链接到<a href="https://chenrt-ggx.github.io/blog/c6bab4c5a3d5">以前提问题的博客</a>；请尝试对自己曾经提出的问题进行解答，并阐明是如何通过看书/实践/讨论弄清楚的；是否原来的问题还不明白，如果有请分析；是否产生了新的问题，如果有请提出。</p></blockquote><h3 id="代码覆盖率"><a class="markdownIt-Anchor" href="#代码覆盖率"></a> 代码覆盖率</h3><p>学期初，笔者认为在条件语句中，影响条件最终判断结果的因素往往有很多，例如下面的伪代码：</p><pre class="highlight"><code class="c++"><span class="hljs-keyword">if</span> (a == TRUE &amp;&amp; <span class="hljs-built_in">func1</span>(b) == TRUE &amp;&amp; c == TRUE) &#123;
    <span class="hljs-built_in">DoFoo</span>(a, b, c);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-built_in">DoBar</span>(a, b, c);
&#125;
</code></pre><p>一个程序员可以简单地让 <code>func1</code> 和变量 <code>c</code> 永远为真，只要模拟变量 <code>a</code> 的值为真或假，就可以覆盖条件的两个分支 <code>DoFoo</code> 和 <code>DoBar</code>，这里的路径覆盖率是 100%，但是条件 <code>func1</code> 和条件 <code>c</code> 的取值为假的情况并没有被考虑进来。</p><p>后笔者在昂神的评论中得知存在“分支覆盖率”，上述例子中的测试可以获得 100% 的路径覆盖率但无法获得 100% 的分支覆盖率；在结对编程作业中，使用 Visual Studio 进行单元测试得到的覆盖率也是分支覆盖率，因此程序员不必面向覆盖率分析工具调整程序的控制结构，而应该从可读性、可维护性出发。</p><p>顺便补充一下，Visual Studio 的单元测试似乎不会计算运算符重载的代码，当时因为这个原因卡了好久，后来换成利用 Lambda 表达式自定义排序，覆盖率一下就上去了。</p><h3 id="goto-语句"><a class="markdownIt-Anchor" href="#goto-语句"></a> GOTO 语句</h3><p>学期初，笔者认为单一出口与程序逻辑清晰关系不大且使用 goto 语句保证函数有单一的出口意义不大，因此《构建之法》中提出的“函数最好有单一的出口，为了达到这一目的，可以使用 goto，只要有助于程序逻辑的清晰体现，什么方法都可以使用，包括 goto 语句”在逻辑上不成立，并在软件工程课程中进行了实践，具体如下：</p><ul><li>结对编程项目，采用 C++ 实现，虽然 C++ 支持 goto 语句，但我们全程没有使用，不影响开发过程。</li><li>团队项目前端，采用 VueJS 实现，其不支持 goto 语句，不影响开发过程。</li><li>团队项目后端，采用 GoLang 实现，虽然 GoLang 支持 goto 语句，但我们全程没有使用，不影响开发过程。</li></ul><p>到目前为止，笔者仍坚持这一观点。</p><p>顺便一提，虽然单一出口与程序逻辑清晰关系不大，但前端到处 Promise 似乎不是很利于程序逻辑清晰，建议<strong>应 await 尽 await，非必要不 Promise</strong>。</p><h3 id="差异化策略"><a class="markdownIt-Anchor" href="#差异化策略"></a> 差异化策略</h3><p>学期初，笔者认为在必要需求中的杀手功能难以直接盈利或在可以接受的开销下实现“差异化”时，对必要需求中的杀手功能采取“抵消”乃至“维持”的方法，转而对辅助需求中的杀手功能采取“优化”乃至“差异化”的方法，也是一种可行的策略，并在软件工程课程中进行了实践，具体如下：</p><ul><li>团队项目中，密码的安全性由 SHA256 算法和盐表保证，前端安全性由 VueJS 保证，后端数据库操作安全性由 sqlx 保证，未进行额外的处理以达到“差异化”。</li><li>团队项目中，前端 UI、Markdown 支持等得到了大幅提升。</li></ul><p>到目前为止，笔者仍坚持这一观点。</p><h3 id="记住用户的选择"><a class="markdownIt-Anchor" href="#记住用户的选择"></a> 记住用户的选择</h3><p>学期初，针对软件服务记住用户选择的问题，笔者的观点如下：</p><ul><li><p>功能方面：</p><ul><li>允许客户端记录未登录用户的选择，这是基本要求。</li><li>允许客户端记录已经登录用户的选择，这样记忆可以与用户绑定，在多用户的情况下便于切换和区分。</li><li>允许服务端记录已经登录用户的选择，这样可以通过服务端在多客户端同步记忆，也可以避免客户端损坏导致记忆丢失。</li><li>对用户选择的记录应该以加密的形式妥善存储，尽可能避免被第三方掌握和破解。</li></ul></li><li><p>用户交互方面：</p><ul><li>允许用户关闭或开启任何记录行为，允许用户删除现有的记忆，这些是属于用户的，用户有权支配它们。</li><li>告知用户软件将如何使用其选择，允许用户关闭任何使用途径。</li><li>上述设置应处于明显、易到达的位置，可提供设置向导帮助用户完成设置。</li></ul></li></ul><p>笔者在软件工程课程中进行了实践，认为上述内容可以进行一些调整和补充，如下：</p><ul><li><p>在讨论客户端记录已经登录用户的选择时，未考虑用户退出登录后的处理，用户退出登录后，对于未存储到服务端的部分，可能的处理包括：</p><ul><li>保留这部分内容，这种处理多出现在本地客户端，例如 QQ。</li><li>删除这部分内容，这种处理多出现在 Web 应用，在团队项目的前端中，我们主要采用了这种处理。</li></ul></li><li><p>对用户选择的记录是否加密可依据其是否敏感进行区分，无需全部加密：</p><ul><li>对于敏感的记录，如剪贴板记录等，应加密存储。</li><li>对于无关紧要的记录，例如在团队项目的前端中，是否显示已读通知、优先显示题目页面还是显示提交页面等，并不敏感，明文存储未尝不可。</li></ul></li><li><p>对于 Web 应用，在用户交互方面的要求可以适当弱化：</p><ul><li>对于允许用户关闭或开启任何记录行为，允许用户删除现有的记忆，如果采取了退出登录即删除的策略，笔者认为可以适当简化实现这一功能。</li><li>对于告知用户软件将如何使用其选择，允许用户关闭任何使用途径，如果采取了纯客户端记录的策略，笔者认为可以适当简化实现这一功能。</li></ul></li></ul><h3 id="探索式测试"><a class="markdownIt-Anchor" href="#探索式测试"></a> 探索式测试</h3><p>学期初，笔者认为将探索式测试定期化或常态化是有利于软件质量提高的，并在软件工程课程中进行了实践，取得了一定成果：</p><ul><li>团队项目中，Alpha 阶段探索式测试发现评测机 Docker 内未禁网。</li><li>团队项目中，Beta 阶段探索式测试发现 Redis 没有设置密码且允许来自其它主机的连接。</li></ul><p>到目前为止，笔者仍坚持这一观点。</p><h2 id="实践与收获"><a class="markdownIt-Anchor" href="#实践与收获"></a> 实践与收获</h2><blockquote><p>软件工程这门学问有很多知识点，这门课强调做中学，在实践中学习知识点。请问你们在项目的需求/设计/实现/测试/发布/维护阶段，共 6 个阶段中都学到了什么知识点，每个阶段只要说明一个知识点即可。</p></blockquote><h3 id="项目需求"><a class="markdownIt-Anchor" href="#项目需求"></a> 项目需求</h3><ul><li>使用 NABCD 分析项目的可行性，尤其 Delivery 需要尽早考虑。</li><li>考虑团队规模、团队成员技术栈与任务量是否匹配。</li><li>熟悉了需求分析文档的撰写过程。</li></ul><h3 id="项目设计"><a class="markdownIt-Anchor" href="#项目设计"></a> 项目设计</h3><ul><li>各个功能在设计时需要所有有关方确认，避免出现理解不同的问题。</li><li>考虑用户的使用习惯，尽量减少用户的学习成本。</li><li>对于涉及代码仓库的功能，需要斟酌采用分支的方式管理还是采用仓库的方式管理。</li><li>熟悉了包括功能规格说明、技术规格说明在内的撰写过程。</li></ul><h3 id="项目实现"><a class="markdownIt-Anchor" href="#项目实现"></a> 项目实现</h3><ul><li>通过自动化工具约束代码风格，保证代码的可读性、可维护性。</li><li>最好保证前后端进度基本一致，前后端可以对接调试，如无法满足前后端进度基本一致，可以采用以下方式：<ul><li>在有后端没前端的情况下，可以通过 Swagger 完成功能的验证。</li><li>在有前端没后端的情况下，可以通过 Mock 完成功能的验证。</li></ul></li></ul><h3 id="项目测试"><a class="markdownIt-Anchor" href="#项目测试"></a> 项目测试</h3><ul><li>单元测试只是一方面，其覆盖率不能说明一切，但重要功能需要保证充分的单元测试。</li><li>安全性测试是测试的重点，不但要保证该做的允许做，还要保证不该做的不允许做。</li><li>压力测试也是测试的重点，需要针对前端资源、API 和特殊服务（如 WebSocket）进行测试。</li><li>需要集成测试、场景测试、探索式测试辅助，以发现更多的问题。</li><li>熟悉了测试报告的撰写过程。</li></ul><h3 id="项目发布"><a class="markdownIt-Anchor" href="#项目发布"></a> 项目发布</h3><ul><li>一个比较好的状态是目标用户自发宣发，形成人传人的链式反应。</li><li>注重用户的反馈，及时对产品迭代更新。</li><li>熟悉了包括发布声明、项目展示文档在内的撰写过程。</li></ul><h3 id="项目维护"><a class="markdownIt-Anchor" href="#项目维护"></a> 项目维护</h3><ul><li>使用自动化工具实现自动风格检查、自动测试、自动构建、自动部署。</li><li>使用 Docker 容器技术，保证环境的一致性并避免多个服务冲突。</li><li>后端记录日志，以便发现问题后寻找原因并解决问题。</li></ul><h2 id="心得与理解"><a class="markdownIt-Anchor" href="#心得与理解"></a> 心得与理解</h2><blockquote><p>结合自己在个人项目/结对编程/团队项目的经历，谈谈自己的理解或心得。</p></blockquote><h3 id="个人项目"><a class="markdownIt-Anchor" href="#个人项目"></a> 个人项目</h3><p>个人项目主要分为构建之法和案例分析两部分，构建之法主要是把笔者从寒假摸鱼状态拉回学习状态，顺便体验了一下 GitLab 的 CI/CD 和 GitHub 的 Actions，并再次确认了 Gitee 就是 <code>%E5%B1%8E</code>，<code>%E7%8B%97</code> 都不用；相比之下笔者感触更深的则是案例分析，心得与理解大概可以概括如下：</p><blockquote><p>仰望星空的人<br>总以为星星就是宝石<br>晶莹、透亮、没有纤瑕</p><p>飞上星空的人知道<br>那儿有灰尘、石渣<br>和地球上一样复杂</p></blockquote><p>在案例分析之前，笔者只试着 Hack 过一些靶场和一些软工级别的项目，从未想过互联网上如此大体量的项目也会存在安全漏洞，直到笔者点了几天炒饭才意识到并非如此，也许这不仅仅是技术的问题，更多的是人的问题。再见了奥比克，你看那消失的村庄。</p><p>顺便，反馈高危漏洞之后三个多月不修，漏洞原封不动可复现，对用户体验不管不顾，只想着自己的腰包，这种垃圾笔者可高攀不起，没错说的就是你，CSDN！衷心祝愿 CSDN 早见棺材爱落泪不落泪，也建议软件工程课程下学期划清界限，回到博客园。</p><blockquote><p>迁博客时注：是我想的太天真了，不但软工还在 CSDN，连 OO 也从博客园转到 CSDN 了，似乎弃明投暗大开历史倒车看来已经变成历史的潮流了。</p></blockquote><h3 id="结对编程"><a class="markdownIt-Anchor" href="#结对编程"></a> 结对编程</h3><p>结对编程本质上可以理解为强制 Windows 平台基于 Visual Studio 的要求单元测试覆盖率的指导书不那么完善的双人 OO 第五单元。笔者虽然体验了一种新型的工作方式：两个人所写的代码不断地处于“复审”的过程，可以及时地发现问题和解决问题，避免把问题拖到后面的阶段，但因为习惯了跨平台和 JetBrains 系列而比较排斥强制 Windows 平台基于 Visual Studio，此外指导书和题目的质量也只能说差强人意，因此总体体验稍差。此外，笔者也收获了基于 Visual Studio 的单元测试与性能测试技巧，更详细的内容可以查看<a href="https://chenrt-ggx.github.io/blog/65c84d81dea5?tip=%E5%BF%AB%E8%B7%91%EF%BC%81%E5%86%8D%E4%B8%8D%E8%B7%91%E5%B0%B1%E8%B7%91%E4%B8%8D%E4%BA%86%E4%BA%86%EF%BC%81">对应博客</a>。最后，笔者还是认为单人编程效率低于结对编程效率低于双人分工编程效率。</p><h3 id="团队项目"><a class="markdownIt-Anchor" href="#团队项目"></a> 团队项目</h3><p>团队项目让笔者体会了团队协作的氛围和一个从构思设计到实现发布的完整过程，这种体验是难得的；尽管经历了一些波折，在不断优化技术方案，发现并解决问题的过程中，笔者加深了对于 VueJS 的理解，并首次接触了 Vuetify 组件库。技术层面，笔者主要负责前端实现与安全性测试，一些比较具体的心得与理解如下：</p><blockquote><p>迁博客时注：写多了 Vue3 再也不想碰 Vue2 和选项式 API 了，OSome 前端维护者或成最大输家（逃。</p></blockquote><h4 id="关于前端交互设计"><a class="markdownIt-Anchor" href="#关于前端交互设计"></a> 关于前端交互设计</h4><ul><li>如果不希望用户进行某个操作，就直接隐藏这个操作，而不是等用户进行了这个操作，再告诉用户你不能进行这个操作。</li><li>如果一个操作不是很敏感或者可以撤销，就不需要用户二次确认，只确认敏感/不可撤销的操作，以此减少用户的工作量。</li><li>对于本部分心得与理解，需要感谢 t123yh 的指导与帮助。</li></ul><h4 id="关于鉴权机制设计"><a class="markdownIt-Anchor" href="#关于鉴权机制设计"></a> 关于鉴权机制设计</h4><ul><li><p>基于 token 的验证是无状态的，其本意在于避免服务端存储 session，从而解决性能问题、多个后端一致性的问题，但其存在两个尴尬的问题：</p><ul><li>如果用户退出登录，无法方便的注销退出登录的 token，因此还是要把 token 存数据库来实现注销。</li><li>如果用户修改密码，无法方便的注销用户所有的 token，以 jwt 为例，即使在 payload 中存储了加盐哈希后的密码，验证时还是要查一次数据库。</li></ul></li><li><p>由上，基于 token 进行验证时，为解决注销问题难免需要访问数据库，这就违背了 token 无状态的初衷，那么不如直接使用 session，并使用 Redis 存储，其好处在于：</p><ul><li>Redis 性能优秀，且可以解决一致性问题。</li><li>分离后端、缓存数据库与主数据库，如需要下线全部用户只要重启 Redis；其它服务变动不影响 Redis 存储的登录状态。</li></ul></li><li><p>对于本部分心得与理解，需要感谢 dhy2000 和 Grape Lemonade 的指导与帮助。</p></li></ul><h2 id="致谢与结语"><a class="markdownIt-Anchor" href="#致谢与结语"></a> 致谢与结语</h2><blockquote><p>杰束了，但没有结束。</p></blockquote><p>祝 OSome 在明年顺利投入使用，此外：</p><ul><li>感谢 VOIDMalkuth 学长不止一次劝笔者快跑，<s>然后笔者就自投罗网了</s>。</li><li>感谢夏春和老师在网络攻防技术课程的付出，帮助笔者更好的完成了安全性测试。</li><li>感谢 Dr-Bluemond 在结对编程过程中的支持与帮助。</li><li>感谢感谢<strong>大本钟下你和我</strong>全体成员在团队项目中的辛勤付出。</li><li>感谢计网实验队友在笔者因为软工放他鸽子的时候的理解与感同身受。</li><li>感谢软件工程课程的老师和助教本学期提供的指导与帮助。</li></ul><img src="/assets/images/buaa-se/hw4/pic.png" width="80%"><p>好像也没什么可说的了，以田佬的一段话收尾吧。</p><blockquote><p>我们写代码，不是就追求写出一坨能跑的东西<br>是要追求严谨认真的态度<br>代码的字里行间都透露着你的精心设计和严谨实现</p></blockquote><p>哦对了，前端人表示，遇事不决的话，<kbd>F12</kbd> 一下总没错，这句话后面是什么呢？</p><span style="display: none">藏点杰语，会有人发现吗 orz<p>在杰难逃，杰哀顺变，杰后余生，再杰再厉<br>殚精杰虑，万杰不复，迫在没杰，杰然不同<br>繁文缛杰，不拘小杰，细枝末杰，杰足先登<br>彼杰我赢，杰尽权力，精疲力杰，杰骜不驯</p><p>最后还有一个不是杰语胜似杰语的：自投罗网<br></p></span><p></p></div><div>Word count: 4.1k</div><div>Reading time: 15min</div><div><div><a href="/archive/2022/06/1">Created 2022-06-23T08:06:09.000Z</a></div></div><div><div><a href="/archive/2022/06/1">Last Modified 2022-06-23T08:06:09.000Z</a></div></div><div><br><br></div></div></content><div><br></div><footer>Copyright © 2021-2023 Chenrt Blog</footer></noscript><div id="app"></div></body></html>