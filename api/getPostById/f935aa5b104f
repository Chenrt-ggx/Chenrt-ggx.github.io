{"id":"f935aa5b104f","title":"面向对象设计与构造第二单元博客作业","created":"2021-04-22T14:57:47.000Z","updated":"2021-04-22T14:57:47.000Z","raw":"<p>[迁移自博客园] | BUAA Object Oriented 2021 Unit2 Summary</p>\n<span id=\"more\"></span>\n<h2 id=\"第一次作业总结\"><a class=\"markdownIt-Anchor\" href=\"#第一次作业总结\"></a> 第一次作业总结</h2>\n<h3 id=\"alpha-版本基于请求\"><a class=\"markdownIt-Anchor\" href=\"#alpha-版本基于请求\"></a> Alpha 版本（基于请求）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-req-uml.jpg\" width=\"45%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-req-seq.png\" width=\"60%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>这个版本功能比较废物，性能比较垃圾，没有前途已经被淘汰了，就不谈可扩展性了。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-req-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-req-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-req-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>设置了一个线程安全类 RequestsQueue，其余部分均没有也不需要同步，采用理论课着重涉及的 synchronized 加锁。</p>\n<p>线程安全类 RequestsQueue 中维护了 Request 的 LinkedList，同步块中均涉及对此 LinkedList 的读或写操作因此必须同步。</p>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>本实现中没有单独的调度器，将公共托盘 RequestsQueue 作为调度器。</p>\n<p>RequestReader 线程可向调度器发送请求或结束信号，ElevatorController 线程可从调度器获取请求或询问上/下方是否存在请求。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>以 ALS 调度为参考，从请求出发进行调度，期间可捎带则捎带，不局限于 ALS 调度，在电梯内部有/无人从内/外部选择主请求时，均支持选择第一个请求/最远距离请求/最近距离请求。</p>\n<p>枚举上述九种组合进行测试，结果显示在笔者的实现下从内/外部选择时均选择最远距离请求时，电梯拥有最佳的性能。本地测试结果显示，在笔者的实现下，相比于 Beta 版本，Alpha 版本的性能落后且差距十分明显，因此从第二次作业开始实现全部基于扫描。</p>\n</li>\n</ul>\n<h3 id=\"beta-版本基于扫描\"><a class=\"markdownIt-Anchor\" href=\"#beta-版本基于扫描\"></a> Beta 版本（基于扫描）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-look-uml.jpg\" width=\"45%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-look-seq.png\" width=\"60%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>功能方面，从本程序到第二次作业的集中式实现和分布式实现均可以快速完成修改，设置了线程安全类从而进一步加强可扩展性；性能方面，主要在于对控制参数的调整，这些参数和开关被集中定义在了 Const 类中，添加和修改较为方便。</p>\n<p>设置了楼层映射机制，可以方便的处理可能增加的负楼层需求，设置了电梯类型映射机制，可以方便的扩展不同类型的电梯。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-look-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-look-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw1-look-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>设置了一个线程安全类 Building，其余部分均没有也不需要同步，在锁的选择方面：</p>\n<ul>\n<li>采用 ReentrantReadWriteLock 显式加锁，并根据方法性质的不同，在使用过程中选择性的采用读或写锁。</li>\n<li>之所以选择 Lock 而不是 synchronized，主要是看了 MY 学长的博客，认为显式的 Lock 更清晰更易于理解，功能也相对丰富一些；之所以选择 ReentrantReadWriteLock 而不是普通的 ReentrantLock 是因为笔者认为逻辑上这样更合理，且在笔者的实现下读操作确实比较多。</li>\n<li>根据本地测试的结果，synchronized，ReentrantLock 和 ReentrantReadWriteLock 三者性能差异都在波动误差范围内。</li>\n</ul>\n<p>具体的，线程安全类 Building 中维护了以下内容，涉及操作 count/building/lastRequests 的方法都进行了同步保护：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> count;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Condition normalEmpty;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Condition morningNotFull;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ArrayList&lt;Floor&gt; building;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> LinkedList&lt;Request&gt; lastRequests;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ReentrantReadWriteLock readWriteLock;\n</code></pre>\n<ul>\n<li>对于 size/hasUpper/hasLower 等只读的方法，加 readWriteLock.readLock。</li>\n<li>对于 put/getUpper/getLower 等涉及写的方法，加 readWriteLock.writeLock。</li>\n</ul>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>与 Alpha 版本中的相应处理完全一致，只是 RequestsQueue 换成了 Building。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>以扫描为基础，电梯从底层到顶层再从顶层到底层往复运行，期间可捎带则捎带，优化包括：</p>\n<ul>\n<li>支持缓冲式 Look 优化，如果电梯内无人且运行方向没有请求而运行反方向有请求，这样的情况连续若干次，电梯掉头运行。</li>\n<li>支持楼层聚集检测，如果电梯内无人且上下均没有请求，考虑此前 MEMORY_VAL 条请求，如果上方的请求超过下方的请求 PREDICT_RANGE 条，向上运行，如果下方的请求超过上方的请求 PREDICT_RANGE 条，向下运行。</li>\n<li>支持归中等待，如果电梯内无人且上下均没有请求，也不满足楼层聚集检测条件，则电梯会向中间楼层移动。</li>\n</ul>\n<p>在参数设置方面，对上述优化的参数进行了枚举，在笔者的实现下的最优参数如下：</p>\n<ul>\n<li>\n<p>缓冲式 Look 优化缓冲一级，即退化为普通 Look 优化，如果电梯内无人且运行方向没有请求而运行反方向有请求，电梯直接掉头运行；开启楼层聚集检测，MEMORY_VAL 取值为 8，PREDICT_RANGE 取值为 5，同时关闭归中等待优化。</p>\n</li>\n<li>\n<p>此版本为本次作业最终提交版本，强测总分 98.3604，后分析发现，问题在于笔者的实现中选择请求时优先取短距离请求，但写出了如下方法计算距离，否则速度可以更快，想穿越回去抽自己：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">distance</span><span class=\"hljs-params\">()</span> &#123;\n    <span class=\"hljs-keyword\">return</span> changeToFloor - changedFromFloor; <span class=\"hljs-comment\">// abs ???</span>\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"测试数据构造\"><a class=\"markdownIt-Anchor\" href=\"#测试数据构造\"></a> 测试数据构造</h3>\n<ul>\n<li>\n<p>Morning 部分，分为如下三个主题：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getMorning</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-built_in\">singleTheme_M</span>(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 12 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only one request, random</span>\n    <span class=\"hljs-comment\">// with min-max</span>\n    <span class=\"hljs-built_in\">doubleTheme_M</span>(<span class=\"hljs-number\">18</span>); <span class=\"hljs-comment\">// 18 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only two request, random</span>\n    <span class=\"hljs-comment\">// with min-max</span>\n    <span class=\"hljs-built_in\">normalTheme_M</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 24 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// o-low/o-mid/o-high/o-random</span>\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>单请求主题：</p>\n<ul>\n<li>仅一个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从底层到顶层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>双请求主题：</p>\n<ul>\n<li>仅两个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从底层到顶层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>标准主题：</p>\n<ul>\n<li>请求数在最大请求数附近，主要测试正确性和性能。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括全部从底层到顶层的数据，和若干随机数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Random 部分，分为如下六个主题：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getRandom</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-built_in\">singleTheme_R</span>(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 12 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only one request, random</span>\n    <span class=\"hljs-comment\">// with max-min and min-max</span>\n    <span class=\"hljs-built_in\">doubleTheme_R</span>(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// 20 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only two request, random</span>\n    <span class=\"hljs-comment\">// with max-min and min-max</span>\n    <span class=\"hljs-built_in\">normalTheme_R</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 144 tot</span>\n    <span class=\"hljs-comment\">/// sudden/dense/scatter</span>\n    <span class=\"hljs-comment\">// i-low/i-mid/i-high/i-random</span>\n    <span class=\"hljs-comment\">// o-low/o-mid/o-high/o-random</span>\n    <span class=\"hljs-built_in\">limitTheme_R</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 40 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// low-high/high-low/random</span>\n    <span class=\"hljs-comment\">// with max-min and min-max</span>\n    <span class=\"hljs-built_in\">crossTheme_R</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 20 tot</span>\n    <span class=\"hljs-comment\">// small amount up with small amount down</span>\n    <span class=\"hljs-comment\">// large range/random range</span>\n    <span class=\"hljs-comment\">// single cross/double cross</span>\n    <span class=\"hljs-built_in\">splitTheme_R</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 20 tot</span>\n    <span class=\"hljs-comment\">// big amount up with big amount down</span>\n    <span class=\"hljs-comment\">// large range/random range</span>\n    <span class=\"hljs-comment\">// single split/double split</span>\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>单请求主题：</p>\n<ul>\n<li>仅一个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从底层到顶层/从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>双请求主题：</p>\n<ul>\n<li>仅两个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从底层到顶层/从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>标准主题：</p>\n<ul>\n<li>请求数在最大请求数附近，主要测试正确性和性能。</li>\n<li>对输入时瞬时输入/密集输入/分散输入进行覆盖测试。</li>\n<li>对起点楼层从低层/从中层/从高层/全楼层随机，终点楼层从低层/从中层/从高层/全楼层随机进行覆盖测试。</li>\n</ul>\n</li>\n<li>\n<p>极限主题：</p>\n<ul>\n<li>请求数在最大请求数附近，主要测试正确性。</li>\n<li>包括从零开始和等一段时间开始，全部输入时间戳相同。</li>\n<li>包括全部从底层到顶层的数据/从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>交叉主题：</p>\n<ul>\n<li>采用分散输入，请求数在最大请求数附近，主要测试性能。</li>\n<li>输入的请求特征为一条较长距离上行接一条较长距离下行/两条较长距离上行接两条较长距离下行。</li>\n</ul>\n</li>\n<li>\n<p>分裂主题：</p>\n<ul>\n<li>采用分散输入，请求数在最大请求数附近，主要测试性能。</li>\n<li>输入的请求特征为十六条较长距离上行接十六条较长距离下行/八条较长距离上行接八条较长距离下行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Night 部分，分为如下三个主题：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getNight</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-built_in\">singleTheme_N</span>(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 12 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only one request, random</span>\n    <span class=\"hljs-comment\">// with max-min</span>\n    <span class=\"hljs-built_in\">doubleTheme_N</span>(<span class=\"hljs-number\">18</span>); <span class=\"hljs-comment\">// 18 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// only two request, random</span>\n    <span class=\"hljs-comment\">// with max-min</span>\n    <span class=\"hljs-built_in\">normalTheme_N</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 20 tot</span>\n    <span class=\"hljs-comment\">// start at zero/wait before start</span>\n    <span class=\"hljs-comment\">// i-low/i-mid/i-high/i-random</span>\n&#125;\n</code></pre>\n<ul>\n<li>\n<p>单请求主题：</p>\n<ul>\n<li>仅一个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>双请求主题：</p>\n<ul>\n<li>仅两个请求，主要测试启动部分。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n<li>\n<p>标准主题：</p>\n<ul>\n<li>请求数在最大请求数附近，主要测试正确性和性能。</li>\n<li>包括从零开始和等一段时间开始。</li>\n<li>包括全部从顶层到底层的数据，和若干随机数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>部分实现技巧：</p>\n<p>分离用于控制的参数，例如：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *mode[] = &#123;<span class=\"hljs-string\">&quot;Morning&quot;</span>, <span class=\"hljs-string\">&quot;Random&quot;</span>, <span class=\"hljs-string\">&quot;Night&quot;</span>&#125;; <span class=\"hljs-comment\">// 表示到达模式定义</span>\n<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> floorPool[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>] = &#123;\n    &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>&#125;, &#123;<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">12</span>&#125;, &#123;<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">20</span>&#125;, &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">20</span>&#125; <span class=\"hljs-comment\">// 表示低/中/高/全楼层段定义</span>\n&#125;;\n<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> timePool[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">2</span>] = &#123;\n    &#123;<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.5</span>&#125;, &#123;<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">10.0</span>&#125;, &#123;<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">130.0</span>&#125; <span class=\"hljs-comment\">// 表示瞬时/短时间/长时间范围定义</span>\n&#125;;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"第二次作业总结\"><a class=\"markdownIt-Anchor\" href=\"#第二次作业总结\"></a> 第二次作业总结</h2>\n<h3 id=\"alpha-版本集中式调度\"><a class=\"markdownIt-Anchor\" href=\"#alpha-版本集中式调度\"></a> Alpha 版本（集中式调度）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-merge-uml.jpg\" width=\"65%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-merge-seq.png\" width=\"75%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>功能方面，和第一次作业相比差异不大，从本次作业的实现到第三次作业的集中式调度的实现也可以快速完成修改。</p>\n<p>性能方面，依旧在于对控制参数的调整，这些参数和开关中通用部分被集中定义在了 Const 类，特异性部分被集中定义在了电梯构造函数，添加和修改较为方便。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-merge-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-merge-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-merge-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>基于第一次作业 Beta 版本迭代开发，保留了此前版本的全部设置，新增线程安全类 SafeOutput，对其中的静态方法 safeOutput 进行了同步。在锁的选择方面，对 safeOutput 采用 synchronized 加锁，因为实在是太简单了，直接放代码了：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">safeOutput</span><span class=\"hljs-params\">(String s)</span> &#123;\n    TimableOutput.println(s);\n&#125;\n</code></pre>\n<p>说就题外话，不加互斥输出强测是不会有问题的，但互测提交的标准答案要求输出时间戳严格单调，为了方便的刀人于是加上了这一功能，此外笔者实现的评测机也支持强测和互测两种标准下的检测。</p>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>与第一次作业 Beta 版本中的相应处理完全一致，只是调度器与一个 RequestReader 和一个 Controller 交互变为与一个 RequestReader 和多个 Controller 交互。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>集中式调度，多部电梯从请求队列中自由竞争请求进行处理。</p>\n<p>考虑到多部电梯自由竞争的情况下每部电梯跑单电梯最优解不一定对应整体最优解，对各个电梯的包括缓冲式 Look 优化/楼层聚集检测/归中等待等的参数再次进行了枚举，考虑了不同电梯执行不同策略的情况，在笔者的实现下的最优参数如下：</p>\n<ul>\n<li>全部执行普通 Look 优化，开启楼层聚集检测，MEMORY_VAL 取值为 8，PREDICT_RANGE 取值为 5，同时开启归中等待优化。</li>\n<li>此外，在笔者测试中还发现，如果将一部电梯的优化全部关闭，即退化为扫描，面对随机数据性能会有一定提升，但对不那么随机的数据性能会有更大的下降，故舍弃。</li>\n<li>此版本为本次作业最终提交版本，强测总分 98.4734，后分析发现存在一个测试点，在等待一段时间后给出若干 1-20 的请求，而此时笔者的电梯因归中等待机制额外跑了半栋楼，导致性能 0 分。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beta-版本分布式调度\"><a class=\"markdownIt-Anchor\" href=\"#beta-版本分布式调度\"></a> Beta 版本（分布式调度）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-split-uml.jpg\" width=\"65%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-split-seq.png\" width=\"75%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>功能方面，和第一次作业相比差异不大，从本次作业的实现到第三次作业的分布式调度的实现也可以快速完成修改。</p>\n<p>性能方面，仍然在于对控制参数的调整，这些参数和开关中通用部分被集中定义在了 Const 类，特异性部分被集中定义在了电梯构造函数，添加和修改较为方便。</p>\n<p>此外考虑到调参的简便性，程序支持从命令行读入参数覆盖预设好的参数，对评测机略作修改即可自动枚举测试的参数。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-split-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-split-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw2-split-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>与 Alpha 版本中的相应处理完全一致。</p>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>本实现中没有单独的调度器，而是将读入线程 RequestReader 作为第一级调度器，对每个电梯，实例化一个请求托盘 Building 作为第二级调度器。</p>\n<p>RequestReader 线程作为第一级调度器，可向合适的第二级调度器发送请求或向全部第二级调度器发送结束信号，Controller 线程可从对应的第二级调度器获取请求或询问上/下方是否存在请求。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>分布式调度，由第一级调度器决定完成请求的电梯，电梯之间彼此完全独立，考虑到独立性，每部电梯的运行策略只需采用第一次作业中的最终策略（对每部电梯进行公共感知优化，每个电梯拥有公共的历史请求队列用于楼层聚集检测）。</p>\n<p>分配按惩罚函数进行，传入参数包括等待进入此电梯中的人数 A，在此电梯中的人数 B，此电梯所在楼层与请求出发楼层的距离 C，以 0 或 1 表示的请求出发楼层是否在电梯运行方向上 D。对惩罚函数实现，考虑两种形式，其一为计算 ABCD 的加权和，其二为计算 ABC 的加权和后，乘以 1+kD，对此两种形式，均需要四个系数。</p>\n<p>对上述优化的参数进行了枚举，在笔者的实现下的最优参数如下：</p>\n<ul>\n<li>采用第二种函数形式，开启公共感知优化，ABC 的权重依次是 13/7/1，且 k 取 1 时电梯具有最佳性能。</li>\n<li>本地测试结果显示，在笔者的实现下，相比于 Alpha 版本，Beta 版本的性能有一定落后，且差异远大于波动误差范围，因此提交过这个版本但没有将其作为最终版本。</li>\n<li>此外测试结果显示，只要 AB 的系数远大于 CD 的系数，两种函数形式均可以得到相近的性能且差异略大于波动误差范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"测试数据构造-2\"><a class=\"markdownIt-Anchor\" href=\"#测试数据构造-2\"></a> 测试数据构造</h3>\n<p>补充了如下所述的电梯添加逻辑，对请求数/时间跨度等进行了调整以适应本次作业。</p>\n<ul>\n<li>\n<p>Morning 部分，向上支持原有的三个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>随机主题：</p>\n<ul>\n<li>请求数在最大请求数附近。</li>\n<li>终点楼层完全随机生成。</li>\n<li>主要测试和性能，对正确性也是不弱的测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Random 部分，向上支持原有的六个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>随机主题：</p>\n<ul>\n<li>请求数在最大请求数附近。</li>\n<li>包括分散输入和密集输入两种类型。</li>\n<li>起点和终点楼层完全随机生成。</li>\n<li>主要测试和性能，对正确性也是不弱的测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Night 部分，向上支持原有的三个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>随机主题：</p>\n<ul>\n<li>请求数在最大请求数附近。</li>\n<li>起点楼层完全随机生成。</li>\n<li>主要测试和性能，对正确性也是不弱的测试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>部分实现技巧：</p>\n<p>对增加电梯的请求的处理：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">getPos</span><span class=\"hljs-params\">()</span> </span>&#123;\n    ppr = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">memset</span>(pos, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(pos));\n    <span class=\"hljs-keyword\">if</span> (ans.<span class=\"hljs-built_in\">size</span>() &amp;&amp; <span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-type\">int</span> tot = <span class=\"hljs-built_in\">rand</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>), rem = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, cur, flag; rem; ++i) &#123;\n        cur = <span class=\"hljs-number\">1</span> + (<span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-built_in\">generator</span>() &amp; <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">if</span> (cur &gt; rem || i + <span class=\"hljs-number\">1</span> == tot)\n            cur = rem;\n        <span class=\"hljs-type\">int</span> tpos = <span class=\"hljs-built_in\">rand</span>(<span class=\"hljs-number\">0</span>, ans.<span class=\"hljs-built_in\">size</span>());\n        rem -= cur, flag = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; ppr &amp;&amp; flag; j++)\n            <span class=\"hljs-keyword\">if</span> (pos[j][<span class=\"hljs-number\">0</span>] == tpos) &#123;\n                pos[j][<span class=\"hljs-number\">1</span>] += cur, flag = <span class=\"hljs-number\">0</span>;\n            &#125;\n        <span class=\"hljs-keyword\">if</span> (flag) &#123;\n            pos[ppr][<span class=\"hljs-number\">0</span>] = tpos, pos[ppr++][<span class=\"hljs-number\">1</span>] = cur;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>采用打印时再随机注入的方式进行添加。</li>\n<li>通过以上函数获得请求添加位置。</li>\n<li>两个不同位置/一个位置两个均可能生成。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三次作业总结\"><a class=\"markdownIt-Anchor\" href=\"#第三次作业总结\"></a> 第三次作业总结</h2>\n<h3 id=\"alpha-版本集中式调度-2\"><a class=\"markdownIt-Anchor\" href=\"#alpha-版本集中式调度-2\"></a> Alpha 版本（集中式调度）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-merge-uml.jpg\" width=\"60%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-merge-seq.png\" width=\"90%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>功能方面，相比于第二单元主要修改在于 Request 类，通过 Request 自身完成换乘，整体结构变化不大，性能方面，又双叒叕在于对控制参数的调整，依旧向上支持命令行输入参数，在此不再赘述。</p>\n<p>实现中为请求的拆分设置了单独的方法，对于可能的更复杂的需求，如可达楼层动态输入等均可方便的支持，只是算法上从枚举变成最短路。</p>\n<p>由于请求队列的线程安全性，对于删除电梯吐出电梯中请求等需求等亦可方便的支持。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-merge-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-merge-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-merge-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>基于第二次作业 Alpha 版本迭代开发，保留了此前版本的全部设置，本次作业中无新增内容。</p>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>与第二次作业 Alpha 版本中的相应处理基本一致。调度器与 Controller 的交互增加了一部分，即 Controller 控制电梯完成请求后，会调用请求的 destroy 方法，如请求存在下一阶段，会将自己的下一阶段放入调度器。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>集中式调度，多部电梯从请求队列中自由竞争请求进行处理，一些细节包括：</p>\n<ul>\n<li>对于每个 MyRequest，使用 PersonRequest 构造，构造过程中会对请求进行拆分，只显示第一部分的请求，其余部分存于 LinkedList，同时提供 destroy 方法，调用后将下一阶段请求放入请求队列 Building。</li>\n<li>实现请求伙伴优化，即将请求放入请求队列时，将请求的下一阶段作为伙伴请求放入伙伴请求队列。电梯调度时，完成普通 Look 优化后开始楼层聚集检测前进行伙伴请求意义上的普通 Look 优化，从而实现第二阶段电梯提前去往换乘点节省时间。</li>\n<li>对请求的拆分采用静态二级拆分，即对 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 计算惩罚值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> 后枚举全部楼层，对每个楼层计算惩罚值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">f(x,i)+f(i,y)+p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>，其中函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(m,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 只静态的考虑两楼层间的距离和各电梯运行一层的时间。</li>\n</ul>\n<p>考虑到多部电梯自由竞争的情况下每部电梯跑单电梯最优解不一定对应整体最优解，在枚举 p 的同时，对各个电梯的包括楼层聚集检测/归中等待等的参数再次进行了枚举，在笔者的实现下的最优参数如下：</p>\n<ul>\n<li>全模式通用优化为全部电梯执行普通 Look 优化，请求伙伴优化，MEMORY_VAL 取值为 8，PREDICT_RANGE 取值为 5，同时开启归中等待优化。</li>\n<li>对 Morning 模式，开启楼层聚集检测，p 取值 800，对 Random 模式，关闭楼层聚集检测，p 取值 800，对 Night 模式，关闭楼层聚集检测，p 取值 1600。</li>\n<li>此版本为本次作业最终提交版本，强测总分 99.8309，除一个 Night 点得分 98.6761 外，没有低于 99 分的测试点。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beta-版本分布式调度-2\"><a class=\"markdownIt-Anchor\" href=\"#beta-版本分布式调度-2\"></a> Beta 版本（分布式调度）</h3>\n<ul>\n<li>\n<p>架构与可扩展性分析：</p>\n<ul>\n<li>\n<p>UML 类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-split-uml.jpg\" width=\"65%\" />\n</li>\n<li>\n<p>UML 类协作图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-split-seq.png\" width=\"90%\" />\n</li>\n<li>\n<p>可扩展性分析：</p>\n<p>与 Alpha 版本基本一致，差别主要在于结束上，电梯在输出时会记录每个请求的到达情况，当所有请求都到达目的地且输入结束时，更新结束信号使各个 Controller 结束。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基于度量的结构分析：</p>\n<ul>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-split-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-split-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/hw3-split-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>同步块设置和锁的选择:</p>\n<p>基于第二次作业 Beta 版本迭代开发，保留了此前版本的全部设置。</p>\n<p>对 RequestReader 类中的 sendRequest 方法，考虑到 MyRequest 在 destroy 时也要通过 sendRequest 方法分配下一阶段请求，额外进行了同步保护。由于需要实现的功能比较简单，采用 synchronized 加锁，同步块中处理语句即动态分配请求给特定电梯。</p>\n</li>\n<li>\n<p>调度器设计与交互：</p>\n<p>与第二次作业 Beta 版本中的相应处理基本一致。调度器与 Controller 的交互增加了一部分，即 Controller 控制电梯完成请求后，会调用请求的 destroy 方法，如请求存在下一阶段，会将自己的下一阶段放入一级调度器。</p>\n</li>\n<li>\n<p>调度策略分析：</p>\n<p>分布式调度，由第一级调度器决定完成请求的电梯，电梯之间彼此完全独立，对换乘的处理和请求伙伴优化同 Alpha 版本。对于请求分配给电梯的过程，理论上应该重新枚举训练，但因本地枚举训练效率的问题，直接将第二次作业中得到的惩罚函数结果乘以电梯运行一层的时间作为分配惩罚值，而将训练重点放在了请求的拆分上。</p>\n<p>对请求的拆分采用动态二级拆分，即修改静态二级拆分的惩罚函数，考虑各个电梯的等待进入人数/电梯中的人数/电梯所在楼层与请求出发楼层的距离和换乘惩罚系数四个参数对应的系数。对上述优化的参数进行了枚举，在笔者的实现下的最优参数如下：</p>\n<ul>\n<li>全模式通用优化为全部电梯执行普通 Look 优化，请求伙伴优化，MEMORY_VAL 取值为 8，PREDICT_RANGE 取值为 5，同时开启归中等待优化。</li>\n<li>对 Morning 模式，开启楼层聚集检测，上述四个系数依次取 4/1/110/200，对 Random 模式，关闭楼层聚集检测，上述四个系数依次取 5/4/90/170，对 Night 模式，关闭楼层聚集检测，上述四个系数依次取 1/6/90/150。</li>\n<li>本地测试结果显示，在笔者的实现下，相比于 Alpha 版本，Beta 版本的性能有一定落后，且差异远大于波动误差范围，因此提交过这个版本但没有将其作为最终版本。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"测试数据构造-3\"><a class=\"markdownIt-Anchor\" href=\"#测试数据构造-3\"></a> 测试数据构造</h3>\n<p>对请求数/时间跨度等进行了调整以适应本次作业。</p>\n<ul>\n<li>\n<p>Morning 部分，向上支持原有的四个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>换乘主题：</p>\n<ul>\n<li>保证所有请求是换乘请求，换乘请求的定义如下所述。</li>\n<li>除此之外的逻辑同上文所述的随机主题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Random 部分，向上支持原有的七个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>换乘主题：</p>\n<ul>\n<li>保证所有请求是换乘请求，换乘请求的定义如下所述。</li>\n<li>包括随机换乘请求和随机大跨度换乘请求两部分。</li>\n<li>除此之外的逻辑同上文所述的随机主题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Night 部分，向上支持原有的四个主题，新增内容包括：</p>\n<ul>\n<li>\n<p>换乘主题：</p>\n<ul>\n<li>保证所有请求是换乘请求，换乘请求的定义如下所述。</li>\n<li>除此之外的逻辑同上文所述的随机主题。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>部分实现技巧：</p>\n<p>换乘型数据是指不换乘的情况下仅 A 类电梯可以完成的请求，对换乘型数据的构造为：</p>\n<pre class=\"highlight\"><code class=\"c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fillChange</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">20</span>; ++i)\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= <span class=\"hljs-number\">20</span>; ++j) &#123;\n            <span class=\"hljs-keyword\">if</span> (i == j || (i &amp; j &amp; <span class=\"hljs-number\">1</span>))\n                <span class=\"hljs-keyword\">continue</span>;\n            <span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">4</span> &amp;&amp; (j &lt; <span class=\"hljs-number\">4</span> || j &gt; <span class=\"hljs-number\">17</span>))\n                <span class=\"hljs-keyword\">continue</span>;\n            <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">17</span> &amp;&amp; (j &lt; <span class=\"hljs-number\">4</span> || j &gt; <span class=\"hljs-number\">17</span>))\n                <span class=\"hljs-keyword\">continue</span>;\n            last[lastCnt].src = i;\n            last[lastCnt++].dst = j;\n        &#125;\n    std::<span class=\"hljs-built_in\">sort</span>(last, last + lastCnt, [](<span class=\"hljs-type\">const</span> node a, <span class=\"hljs-type\">const</span> node b) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">abs</span>(a.src - a.dst) &gt; <span class=\"hljs-built_in\">abs</span>(b.src - b.dst);\n    &#125;);\n&#125;\n</code></pre>\n<ul>\n<li>采用枚举所有组合，选择符合要求的存入 last 数组的方式构造。</li>\n<li>对 last 数组按请求距离从大到小排序是为了便于筛选。例如需要获得大跨度换乘请求时，可以从 0 到四分之一元素数量范围内随机数组下标。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"本地测试方式简述\"><a class=\"markdownIt-Anchor\" href=\"#本地测试方式简述\"></a> 本地测试方式简述</h2>\n<p>本地自动测试的主要逻辑采用 C++ 实现，支持指定测试数据/使用数据生成器，支持 Windows/Linux 双平台，Linux 下额外支持 CPU 时间测试，实现了层次化测试，并发测试，自动统计分析性能。</p>\n<ul>\n<li>\n<p>层次化自动测试之第一层，单进程跑点：</p>\n<ul>\n<li>\n<p>AutoTest：</p>\n<ul>\n<li>采用 C++ 实现，调用 Runner 和 Checker 进行测试。</li>\n<li>数据传递主要分为两种形式，少量数据通过命令行传递，大量数据通过文件传递。</li>\n<li>通过条件编译完成 Windows/Linux 双平台支持。</li>\n</ul>\n</li>\n<li>\n<p>Checker：</p>\n<p>采用 Java 实现，模拟了电梯运行过程，支持强测标准允许少量输出乱序和互测标准强制输出严格单调。之所以没有采用过程化按条目检查结果，主要基于可扩展性考虑，另一方面是为了避免按条目检查时可能发生的遗漏。</p>\n<p>在设计报错信息的时候充分考虑了趣味性，部分摘录如下（<s>此处应有表情包</s>）：</p>\n<pre class=\"highlight\"><code class=\"plain\">wow! your elevator is flying\nwow! your elevator is digging\nwow! your elevator can born baby\nwow! your elevator is teleporting\nwow! your elevator move with door open\nwow! your elevator can predict the future\nwow! your elevator can expand itself\nwow! your elevator can eat passenger\nwow! your elevator open in a wrong floor\nwow! your passenger is able to split up\nwow! your passenger can go through wall\n</code></pre>\n<ul>\n<li>\n<p>类关系图：</p>\n<img src=\"/assets/images/buaa-oo/unit2/checker-uml.jpg\" width=\"30%\" />\n</li>\n<li>\n<p>代码规模统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/checker-line.jpg\" />\n</li>\n<li>\n<p>类复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/checker-class.jpg\" width=\"25%\" />\n</li>\n<li>\n<p>方法复杂度统计：</p>\n<img src=\"/assets/images/buaa-oo/unit2/checker-method.jpg\" width=\"45%\" />\n</li>\n</ul>\n<p>复杂度比较高的是 Checker 中用于过程性预处理和善后等的方法。</p>\n</li>\n<li>\n<p>Runner：</p>\n<ul>\n<li>采用 Python 实现，核心为 subprocess 通过手动刷新实现定时投喂输入。</li>\n<li>因 process_time 方法的 subprocess 支持问题，Windows 下没有记录 CPU 时间，Linux 下采用 time 命令记录 CPU 时间。</li>\n<li>Whidows 下采用 taskkill /f /pid 杀死超时进程，Linux 下采用 timeout 命令限制进程运行时间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>层次化自动测试之第二层，多进程跑点：</p>\n<ul>\n<li>\n<p>MultTest：</p>\n<ul>\n<li>根据命令行输入或控制台输入，确定并发数。</li>\n<li>根据并发数复制上述自动测试之第一层。</li>\n<li>按照对并发数的余数分别对测试点进行测试。</li>\n</ul>\n</li>\n<li>\n<p>ResultMerger：</p>\n<ul>\n<li>汇总 MultTest 运行的结果，清理不必要的文件和测试时产生的临时文件。</li>\n<li>执行 ResultMerger 后，文件夹中内容将变为和执行 AutoTest 单进程完成全部测试点完全一致。</li>\n<li>对更高层的自动测试，通过 ResultMerger 实现本层完全透明。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>层次化自动测试之第三层，多程序联测：</p>\n<ul>\n<li>\n<p>LimitTest：</p>\n<ul>\n<li>主要用于惩罚函数调参，也可用于多重测试，仅适配了 Linux。</li>\n<li>评测机会枚举准备好的参数的全部组合，按数量复制上述自动测试之第二层进行测试。</li>\n<li>测试所采用的参数将通过命令行输入给被测程序。</li>\n<li>由于测试规模过大，同时测试电脑扛不住，对并发数进行了限制。</li>\n<li>使用 <code>ps -ef | wc -l</code> 获得当前进程数，若当前进程数超过启动时进程数 300 以上，等待当前批次进程跑完再继续测试。</li>\n</ul>\n</li>\n<li>\n<p>SpeedTest：</p>\n<ul>\n<li>根据程序数复制上述自动测试之第二层。</li>\n<li>对多个程序，按照指定的并发数测试全部测试点。</li>\n</ul>\n</li>\n<li>\n<p>TimeAnalyse：</p>\n<ul>\n<li>对每个子文件夹，先调用其 ResultMerger，再统计程序性能。</li>\n<li>统计内容包括每个主题的平均运行时间，总运行时间和平均运行时间和。</li>\n<li>第三次作业额外统计每个主题的平均等待时间，总等待时间和平均等待时间和。</li>\n<li>在输出每个程序性能的同时，对每个性能指标输出前若干名以便查看。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"程序-bug-分析\"><a class=\"markdownIt-Anchor\" href=\"#程序-bug-分析\"></a> 程序 Bug 分析</h2>\n<ul>\n<li>\n<p>本人程序 Bug：</p>\n<ul>\n<li>调完样例和随便随机的三五个点之后基本没啥 Bug 了。</li>\n<li>第三次作业换乘完输出信息和塞回请求队列写反了，本地高并发强测下可能出现先进换乘电梯再出原来电梯的情况。</li>\n<li>评测机在用的时候被发现了一大堆 Bug，大部分是使用体验上的无关紧要，除此之外主要是评测机误判了一些其实正确的输出。</li>\n<li>自认为本地测试还算充分，三次作业强测和互测均没有发现 Bug。</li>\n</ul>\n</li>\n<li>\n<p>他人程序 Bug：</p>\n<ul>\n<li>\n<p>第一次作业：</p>\n<pre class=\"highlight\"><code class=\"plain\">person1: 00 WA\nperson2: 03 WA // dispatch algorithm tle, done\nperson3: 01 WA // refuse to send passenger, done\nperson4: 04 WA // may steal time, unable to hack\nperson5: 00 WA\nperson6: 00 WA\nperson7: 00 WA\nperson8: 26 WA // elevator expand, done\n</code></pre>\n<p>注：may steal time 指可能存在未 Sleep 满导致输出先于请求输入的情况，person4 的 Bug 在本地 Ubuntu 下超过 200 路并发时，每百点大概率复现一次。</p>\n</li>\n<li>\n<p>第二次作业：</p>\n<pre class=\"highlight\"><code class=\"plain\">person1: 000 WA\nperson2: 064 WA // elevator is digging, done\nperson3: 007 WA // unable to stop, missed\nperson4: 011 WA // run time error, unable to hack\nperson5: 292 WA // passenger split, born baby, run time error, done\nperson6: 000 WA\nperson7: 004 WA // cpu time in danger, but not ctle\nperson8: 000 WA\n</code></pre>\n<p>注：person4 的 Bug 在本地 Ubuntu 下超过 200 路并发时，每百点大概率复现一次。考虑到本地性能，本地评测对 CPU 时间限制为 2s，person7 少量测试点的 CPU 时间在 2s 出头，发生 ctle 主要是本地限制过强的问题。</p>\n<p>此外对 person5 表示歉意，除本地稳定刀 person5 的点外，本地稳定刀 person3 小几率刀 person5 的测试点交上去没刀到 person3 却把 person5 刀了，给您带来的压力与不便敬请谅解。</p>\n</li>\n<li>\n<p>第三次作业：</p>\n<pre class=\"highlight\"><code class=\"plain\">person1: 000 WA\nperson2: 000 WA\nperson3: 026 WA // born baby and run time error, done\nperson4: 000 WA\nperson5: 000 WA\nperson6: 010 WA // run time error, done\nperson7: 000 WA\nperson8: 070 WA // cpu time limit exceed, done\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>测试策略与有效性：</p>\n<ul>\n<li>\n<p>有效性分析：</p>\n<ul>\n<li>三次作业中均发现了他人的 Bug；存在这样的 Bug：只被我发现而未被同房间其它人发现；不存在这样的 Bug：未被我发现而被同房间其它人发现。</li>\n<li>所有发现的 Bug 本地均可复现，只是有些需要高并发跑多点才可复现，故无法在互测下复现。</li>\n<li>综上所述，自认为目前的测试方案是有一定有效性的。</li>\n</ul>\n</li>\n<li>\n<p>对线程安全针对性测试：</p>\n<p>主要采用高并发多重测试的方式，分为弱鸡模式，普通模式，强测模式，至尊模式，以下测试在 Ubuntu20.04 物理机进行：</p>\n<ul>\n<li>弱鸡模式下 8 路并发跑 16 个随机测试点，进行最基本的测试。</li>\n<li>普通模式下 160 路并发跑准备好的全部测试点，进行基本功能和性能测试。</li>\n<li>强测模式下多人联测，以约 240 至 320 路总并发数跑准备好的全部测试点，主要进行性能测试，也进行进一步功能测试。</li>\n<li>至尊模式下对一份程序，本地三个随机种子跑总共 120 遍，全程并发不低于 250 路，存在间歇性轮询的标程模拟强测中可能出现的因轮询导致的计算资源进一步紧张。</li>\n</ul>\n<p>的确，本地跑一遍没出 Bug 不代表程序没有 Bug，但经过至尊模式依旧没有测出 Bug，自认为还是可以一定程度说明问题的（<s>OJ 上的并发可能也就这么多</s>）。</p>\n</li>\n<li>\n<p>与第一单元测试模式的差异：</p>\n<ul>\n<li>第一单元全程单进程跑点，一方面是因为不存在线程安全问题，另一方面是因为每个测试点测试速度很快，且第一单元是计算密集型任务，并发加速效果不见得会好。</li>\n<li>第二单元需要并发跑点，一方面是因为高并发下比较容易测出线程安全问题，另一方面平均每个测试点的运行时间较长但 CPU 时间不长，顺序跑点过于低效，故并发加速。</li>\n</ul>\n</li>\n<li>\n<p>与第一单元主要难点的差异：</p>\n<ul>\n<li>第一单元的评测机构造是相对简单的，在 sympy 帮助下简单搭出来一个能用的评测机基本有手就行。第二单元的评测机构造是有难度的，一方面实现定时投喂需要一定的技巧，另一方面本单元的 SPJ 需手工实现。</li>\n<li>第一单元的数据构造是有难度的，暴力随机的数据强度大多不太行，需要进行大量的半手工/手工数据构造，具体可参考笔者上一单元的博客。第二单元的数据构造是相对简单的，暴力随机的数据本就有一定的强度，实现对更高强度数据的构造也只要对构造逻辑进行简单的丰富。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"心得体会\"><a class=\"markdownIt-Anchor\" href=\"#心得体会\"></a> 心得体会</h2>\n<ul>\n<li>\n<p>线程安全方面：</p>\n<p>学习的过程中研读了 MY 学长的博客，深以为然收获很大。想明白线程安全之后写就很容易了，基本没有出过线程安全问题。</p>\n</li>\n<li>\n<p>层次化设计方面：</p>\n<p>笔者感觉层次化设计在作业中体现的不是很明显，比较层次化的实现（分布式）性能都不咋地，不过层次化设计在构造评测机的时候体现非常明显，相比于第一单元，本单元的评测机有明显的层次化，这一单元的评测机的构造让笔者真正体会到了迭代开发的感觉，回看第一版评测机与最终版评测机，甚至有些不可思议，部分迭代内容如下：</p>\n<blockquote>\n<p>修复了错误信息写入异常问题。<br />\n修复了 Linux 下墙钟时间异常的问题。<br />\n修复了 Night 模式下的数据格式错误的问题。<br />\n修改了 AutoTest 中临时文件的清理方式。<br />\n修改了 Runner 中的输入基准时间。<br />\n修改了 SpeedTest 中获取测试程序总数的方式，为控制台读入。<br />\n修改了 TimeAnalyze 中获取测试程序总数的方式，为控制台读入。<br />\n修改了 TimeAnalyze 中获取测试用例总数的方式，为控制台读入。<br />\n修复了 Runner 存在投喂时间偏移的问题。<br />\n修复了 Checker 没有输出增加电梯信息的问题。<br />\n修复了 AutoTest 将未正常结束程序时间记为 0 的问题，已修改为按 210s 计算。<br />\n修复了 TimeAnalyze 将未正常结束程序时间记为 0 的问题，已修改为按 210s 计算。<br />\n修复了 TimeAnalyze 的输出格式错误问题。<br />\n调整了 C++ 文件后缀，统一进行了编译优化。<br />\n调整了 AutoTest 的结束机制，批量测试模式下结束即关闭窗口。<br />\n调整了 MultTest 释放测试用例逻辑，增强了性能。</p>\n</blockquote>\n<p>在此也要特别感谢在进行评测机开发和性能测试的过程中，对笔者提出宝贵意见和建议的朋友们。</p>\n<blockquote>\n<p>迁博客时注：怎么会有 NT 不会起多进程于是命令行起一堆 Gnome Terminal 啊。</p>\n</blockquote>\n</li>\n<li>\n<p>一些建议：</p>\n<p>建议增加 Pre 4 电梯输出序列检查，对一个电梯输出序列，如果合法输出 True，否则输出任意非 True 字符串，这样到第二单元就可以直接用了，本地搭评测机的成本就低了一些。</p>\n<blockquote>\n<p>迁博客时注：好家伙然后整个 Pre 都莫得了。</p>\n</blockquote>\n<p>给 k 次连测机会，对每次 hack 数据提交，可以选择测试 1 + x 次，其中 x 限制为不超过 k 的非负整数，对提交的全部 hack 数据，要求 x 的总和不超过 k，这样刀不好复现的 Bug 会舒服不少。</p>\n<p>提供更多的 hack 信息，如哪一个数据刀了哪个人，交上去若干刀发现只中了一部分的时候就很尴尬，不知道没刀中谁也不好补刀，另一种尴尬情况是想刀 A 实际刀中了 B，却误以为刀中了 A 没接着刀把 A 放过了。</p>\n<p>加强题目，包括但不限于增加负楼层，Morning/Random/Night 模式动态切换，动态输入不同种类电梯的可达楼层并保证任意两个楼层可达，<s>将这份惊喜与感动送给我们的学弟学妹们（逃）</s>。</p>\n<blockquote>\n<p>迁博客时注：怎么能少了横着走的电梯（<s>大雾</s>）和无向图电车调度（<s>滴滴打鬼</s>）。</p>\n</blockquote>\n</li>\n</ul>\n","length":"9.7k","time":"35min","categories":["Buaa","OO"],"tags":["Java","C++"]}