{"id":"2db00ccb4ac9","title":"面向对象设计与构造容器总结作业","created":"2021-05-29T01:43:40.000Z","updated":"2021-05-29T01:43:40.000Z","raw":"<p>[迁移自博客园] | BUAA Object Oriented 2021 Collections Summary</p>\n<span id=\"more\"></span>\n<h2 id=\"map-系列常用容器\"><a class=\"markdownIt-Anchor\" href=\"#map-系列常用容器\"></a> Map 系列常用容器</h2>\n<h3 id=\"treemap\"><a class=\"markdownIt-Anchor\" href=\"#treemap\"></a> TreeMap</h3>\n<p>基于红黑树实现，保证 Key 有序，定义如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * A Red-Black tree based &#123;<span class=\"hljs-doctag\">@link</span> NavigableMap&#125; implementation.\n * The map is sorted according to the &#123;<span class=\"hljs-doctag\">@linkplain</span> Comparable natural\n * ordering&#125; of its keys, or by a &#123;<span class=\"hljs-doctag\">@link</span> Comparator&#125; provided at map\n * creation time, depending on which constructor is used.\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entry</span>&lt;K,V&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Map</span>.Entry&lt;K,V&gt; &#123;\n    K key;\n    V value;\n    Entry&lt;K,V&gt; left;\n    Entry&lt;K,V&gt; right;\n    Entry&lt;K,V&gt; parent;\n    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">color</span> <span class=\"hljs-operator\">=</span> BLACK;\n&#125;\n</code></pre>\n<p>插入删除查找采用非递归实现，迭代效率较差，复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span><span class=\"mclose\">)</span></span></span></span>，相关代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">final</span> Entry&lt;K,V&gt; <span class=\"hljs-title function_\">nextEntry</span><span class=\"hljs-params\">()</span> &#123;\n    Entry&lt;K,V&gt; e = next;\n    <span class=\"hljs-keyword\">if</span> (e == <span class=\"hljs-literal\">null</span>)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoSuchElementException</span>();\n    <span class=\"hljs-keyword\">if</span> (modCount != expectedModCount)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentModificationException</span>();\n    next = successor(e);\n    lastReturned = e;\n    <span class=\"hljs-keyword\">return</span> e;\n&#125;\n</code></pre>\n<p>上面代码中的 successor 方法如下，可以看到寻找后继需要遍历 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\log{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span></span> 数量级的结点：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class=\"hljs-title function_\">successor</span><span class=\"hljs-params\">(Entry&lt;K,V&gt; t)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (t == <span class=\"hljs-literal\">null</span>)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (t.right != <span class=\"hljs-literal\">null</span>) &#123;\n        Entry&lt;K,V&gt; p = t.right;\n        <span class=\"hljs-keyword\">while</span> (p.left != <span class=\"hljs-literal\">null</span>)\n            p = p.left;\n        <span class=\"hljs-keyword\">return</span> p;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        Entry&lt;K,V&gt; p = t.parent;\n        Entry&lt;K,V&gt; ch = t;\n        <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">null</span> &amp;&amp; ch == p.right) &#123;\n            ch = p;\n            p = p.parent;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> p;\n    &#125;\n&#125;\n</code></pre>\n<p>适用于需要维护顺序的情况，面向对象设计与构造第三单元笔者没有使用此容器。</p>\n<h3 id=\"hashmap\"><a class=\"markdownIt-Anchor\" href=\"#hashmap\"></a> HashMap</h3>\n<p>基于哈希表实现，拉链法解决冲突，链长超过 8 时改红黑树处理冲突，防止卡链的情况，定义如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * The bin count threshold for using a tree rather than list for a\n * bin. Bins are converted to trees when adding an element to a\n * bin with at least this many nodes. The value must be greater\n * than 2 and should be at least 8 to mesh with assumptions in\n * tree removal about conversion back to plain bins upon\n * shrinkage.\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">TREEIFY_THRESHOLD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">8</span>;\n\n<span class=\"hljs-comment\">/**\n * The bin count threshold for untreeifying a (split) bin during a\n * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n * most 6 to mesh with shrinkage detection under removal.\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">UNTREEIFY_THRESHOLD</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">6</span>;\n</code></pre>\n<p>迭代效率较差，需要遍历整个哈希数组，相关代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">final</span> Node&lt;K,V&gt; <span class=\"hljs-title function_\">nextNode</span><span class=\"hljs-params\">()</span> &#123;\n    Node&lt;K,V&gt;[] t;\n    Node&lt;K,V&gt; e = next;\n    <span class=\"hljs-keyword\">if</span> (modCount != expectedModCount)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentModificationException</span>();\n    <span class=\"hljs-keyword\">if</span> (e == <span class=\"hljs-literal\">null</span>)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoSuchElementException</span>();\n    <span class=\"hljs-keyword\">if</span> ((next = (current = e).next) == <span class=\"hljs-literal\">null</span> &amp;&amp; (t = table) != <span class=\"hljs-literal\">null</span>) &#123;\n        <span class=\"hljs-keyword\">do</span> &#123;&#125; <span class=\"hljs-keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"hljs-literal\">null</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> e;\n&#125;\n</code></pre>\n<p>适用于无所谓顺序，且插入删除查找较多而遍历不多的情况，是面向对象设计与构造第三单元中笔者绝大多数容器的选择。</p>\n<h3 id=\"linkedhashmap\"><a class=\"markdownIt-Anchor\" href=\"#linkedhashmap\"></a> LinkedHashMap</h3>\n<p>继承 HashMap，额外维护双向链表，定义如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * &lt;p&gt;Hash table and linked list implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface,\n * with predictable iteration order. This implementation differs from\n * &lt;tt&gt;HashMap&lt;/tt&gt; in that it maintains a doubly-linked list running through\n * all of its entries. This linked list defines the iteration ordering,\n * which is normally the order in which keys were inserted into the map\n * (&lt;i&gt;insertion-order&lt;/i&gt;). Note that insertion order is not affected\n * if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map. (A key &lt;tt&gt;k&lt;/tt&gt; is\n * reinserted into a map &lt;tt&gt;m&lt;/tt&gt; if &lt;tt&gt;m.put(k, v)&lt;/tt&gt; is invoked when\n * &lt;tt&gt;m.containsKey(k)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to\n * the invocation.)\n */</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;K,V&gt;\n<span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HashMap</span>&lt;K,V&gt;\n<span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Map</span>&lt;K,V&gt;\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entry</span>&lt;K,V&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">HashMap</span>.Node&lt;K,V&gt; &#123;\n    Entry&lt;K,V&gt; before, after;\n    Entry(<span class=\"hljs-type\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        <span class=\"hljs-built_in\">super</span>(hash, key, value, next);\n    &#125;\n&#125;\n</code></pre>\n<p>插入删除开销增加，迭代性能增加，迭代部分代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">final</span> LinkedHashMap.Entry&lt;K,V&gt; <span class=\"hljs-title function_\">nextNode</span><span class=\"hljs-params\">()</span> &#123;\n    LinkedHashMap.Entry&lt;K,V&gt; e = next;\n    <span class=\"hljs-keyword\">if</span> (modCount != expectedModCount)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentModificationException</span>();\n    <span class=\"hljs-keyword\">if</span> (e == <span class=\"hljs-literal\">null</span>)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NoSuchElementException</span>();\n    current = e;\n    next = e.after;\n    <span class=\"hljs-keyword\">return</span> e;\n&#125;\n</code></pre>\n<p>适用于无所谓顺序，且迭代较多的情况，是面向对象设计与构造第三单元笔者维护表情和组内维护人的容器。</p>\n<h2 id=\"set-系列常用容器\"><a class=\"markdownIt-Anchor\" href=\"#set-系列常用容器\"></a> Set 系列常用容器</h2>\n<blockquote>\n<p>这世上本没有 Set，Map 的 Value 成了 Object，也就有了 Set（代码以 HashSet 为例）。</p>\n</blockquote>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * This class implements the &lt;tt&gt;Set&lt;/tt&gt; interface, backed by a hash table\n * (actually a &lt;tt&gt;HashMap&lt;/tt&gt; instance). It makes no guarantees as to the\n * iteration order of the set; in particular, it does not guarantee that the\n * order will remain constant over time. This class permits the &lt;tt&gt;null&lt;/tt&gt;\n * element.\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">transient</span> HashMap&lt;E,Object&gt; map;\n\n<span class=\"hljs-comment\">/**\n * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has\n * default initial capacity (16) and load factor (0.75).\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HashSet</span><span class=\"hljs-params\">()</span> &#123;\n    map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n&#125;\n</code></pre>\n<h3 id=\"treeset\"><a class=\"markdownIt-Anchor\" href=\"#treeset\"></a> TreeSet</h3>\n<ul>\n<li>是 TreeMap 的 keySet。</li>\n<li>具体使用场景和上述对应的 Map 基本一致。</li>\n</ul>\n<h3 id=\"hashset\"><a class=\"markdownIt-Anchor\" href=\"#hashset\"></a> HashSet</h3>\n<ul>\n<li>是 HashMap 的 keySet。</li>\n<li>具体使用场景和上述对应的 Map 基本一致。</li>\n</ul>\n<h3 id=\"linkedhashset\"><a class=\"markdownIt-Anchor\" href=\"#linkedhashset\"></a> LinkedHashSet</h3>\n<ul>\n<li>是 LinkedHashMap 的 keySet。</li>\n<li>具体使用场景和上述对应的 Map 基本一致。</li>\n</ul>\n<h2 id=\"list-系列常用容器\"><a class=\"markdownIt-Anchor\" href=\"#list-系列常用容器\"></a> List 系列常用容器</h2>\n<h3 id=\"arraylist\"><a class=\"markdownIt-Anchor\" href=\"#arraylist\"></a> ArrayList</h3>\n<p>基于变长数组实现，地方不够了扩容到 1.5 倍后复制，相关代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Increases the capacity to ensure that it can hold at least the\n * number of elements specified by the minimum capacity argument.\n *\n * <span class=\"hljs-doctag\">@param</span> minCapacity the desired minimum capacity\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">grow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> minCapacity)</span> &#123;\n    <span class=\"hljs-comment\">// overflow-conscious code</span>\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">oldCapacity</span> <span class=\"hljs-operator\">=</span> elementData.length;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newCapacity</span> <span class=\"hljs-operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"hljs-number\">0</span>)\n        newCapacity = minCapacity;\n    <span class=\"hljs-keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"hljs-number\">0</span>)\n        newCapacity = hugeCapacity(minCapacity);\n    <span class=\"hljs-comment\">// minCapacity is usually close to size, so this is a win:</span>\n    elementData = Arrays.copyOf(elementData, newCapacity);\n&#125;\n</code></pre>\n<p>适用于需要维护原始顺序，且询问多于插入删除的情况，面向对象设计与构造第三单元笔者没有使用这一容器。</p>\n<h3 id=\"linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#linkedlist\"></a> LinkedList</h3>\n<p>基于双向链表实现，不多赘述，适用于需要维护原始顺序，插入删除多于询问的情况，是面向对象设计与构造第三单元笔者维护人收到的消息的容器。</p>\n<h3 id=\"vector\"><a class=\"markdownIt-Anchor\" href=\"#vector\"></a> Vector</h3>\n<p>基于变长数组实现，地方不够了扩容到 2 倍后复制，相关代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * The maximum size of array to allocate.\n * Some VMs reserve some header words in an array.\n * Attempts to allocate larger arrays may result in\n * OutOfMemoryError: Requested array size exceeds VM limit\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">MAX_ARRAY_SIZE</span> <span class=\"hljs-operator\">=</span> Integer.MAX_VALUE - <span class=\"hljs-number\">8</span>;\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">grow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> minCapacity)</span> &#123;\n    <span class=\"hljs-comment\">// overflow-conscious code</span>\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">oldCapacity</span> <span class=\"hljs-operator\">=</span> elementData.length;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newCapacity</span> <span class=\"hljs-operator\">=</span> oldCapacity + ((capacityIncrement &gt; <span class=\"hljs-number\">0</span>) ? capacityIncrement : oldCapacity);\n    <span class=\"hljs-keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"hljs-number\">0</span>)\n        newCapacity = minCapacity;\n    <span class=\"hljs-keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"hljs-number\">0</span>)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n&#125;\n</code></pre>\n<p>与 ArrayList 不同，Vector 进行了同步，是线程安全的，以 add 方法为例，相关代码如下：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * &lt;p&gt;As of the Java 2 platform v1.2, this class was retrofitted to\n * implement the &#123;<span class=\"hljs-doctag\">@link</span> List&#125; interface, making it a member of the\n * &lt;a href=&quot;&#123;<span class=\"hljs-doctag\">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;\n * Java Collections Framework&lt;/a&gt;. Unlike the new collection\n * implementations, &#123;<span class=\"hljs-doctag\">@code</span> Vector&#125; is synchronized. If a thread-safe\n * implementation is not needed, it is recommended to use &#123;<span class=\"hljs-doctag\">@link</span>\n * ArrayList&#125; in place of &#123;<span class=\"hljs-doctag\">@code</span> Vector&#125;.\n */</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(E e)</span> &#123;\n    modCount++;\n    ensureCapacityHelper(elementCount + <span class=\"hljs-number\">1</span>);\n    elementData[elementCount++] = e;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n</code></pre>\n<p>在并发编程中可以考虑使用这一容器，面向对象设计与构造第三单元笔者没有使用这一容器。</p>\n","length":"1.7k","time":"8min","categories":["Buaa","OO"],"tags":["Java","Collections"]}