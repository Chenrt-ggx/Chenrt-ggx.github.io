{"id":"abdbfce87514","title":"X86 汇编程序设计课程整理（上）","created":"2022-06-12T14:26:52.000Z","updated":"2022-06-12T14:26:52.000Z","raw":"<p>[迁移自博客园] | BUAA 2022 x86 Assembly Programming Summary</p>\n<span id=\"more\"></span>\n<h2 id=\"机器基础知识\"><a class=\"markdownIt-Anchor\" href=\"#机器基础知识\"></a> 机器基础知识</h2>\n<img src=\"/assets/images/buaa-x86/pic-1.png\" />\n<h3 id=\"寄存器\"><a class=\"markdownIt-Anchor\" href=\"#寄存器\"></a> 寄存器</h3>\n<ul>\n<li>\n<p>AX、BX、CX、DX 寄存器：</p>\n<p>为 16 位，可分为两个 8 位：AH、AL、BH、BL、CH、CL、DH、DL。</p>\n</li>\n<li>\n<p>SS、SP、BP 寄存器：</p>\n<p>SS:SP 组成当前堆栈，SS 为堆栈段寄存器，SP 为 16 位堆栈指针；BP 为 16 位参数指针（基址指针）。</p>\n</li>\n<li>\n<p>CS、IP 寄存器：</p>\n<p>CS:IP 组成当前可执行点；CS 为代码段寄存器，IP 为指令指针（指令计数器）。</p>\n</li>\n<li>\n<p>DS、SI、ES、DI 寄存器：</p>\n<ul>\n<li>DS 为数据段寄存器。</li>\n<li>SI 为字符串指针，指向源串。</li>\n<li>ES 为附加段寄存器。</li>\n<li>DI 为字符串指针，指向目的串。</li>\n</ul>\n</li>\n<li>\n<p>PSW 寄存器：</p>\n<p>标志寄存器，有 16 个标志位：</p>\n<ul>\n<li>\n<p>正常情况下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">15</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">13</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">11</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">OF</td>\n<td style=\"text-align:center\">DF</td>\n<td style=\"text-align:center\">IF</td>\n<td style=\"text-align:center\">TF</td>\n<td style=\"text-align:center\">SF</td>\n<td style=\"text-align:center\">ZF</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">AF</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">PF</td>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:center\">CF</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>Debug 情况下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">15</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">13</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">11</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CY</td>\n<td style=\"text-align:center\">NC</td>\n<td style=\"text-align:center\">PE</td>\n<td style=\"text-align:center\">OP</td>\n<td style=\"text-align:center\">AC</td>\n<td style=\"text-align:center\">NC</td>\n<td style=\"text-align:center\">ZR</td>\n<td style=\"text-align:center\">NZ</td>\n<td style=\"text-align:center\">NG</td>\n<td style=\"text-align:center\">PL</td>\n<td style=\"text-align:center\">EI</td>\n<td style=\"text-align:center\">DI</td>\n<td style=\"text-align:center\">DN</td>\n<td style=\"text-align:center\">UP</td>\n<td style=\"text-align:center\">OV</td>\n<td style=\"text-align:center\">NV</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>标志位意义：</p>\n<ul>\n<li>OF：溢出标志。</li>\n<li>DF：方向标志（地址递增/递减）。</li>\n<li>IF：中断标志。</li>\n<li>TF：陷阱标志。</li>\n<li>SF：符号标志。</li>\n<li>ZF：零标志（为 1 则运算结果为 0，为 0 则运算结果非 0）。</li>\n<li>AF：辅助进位标志。</li>\n<li>PF：奇偶标志。</li>\n<li>CF：进位标志。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储器\"><a class=\"markdownIt-Anchor\" href=\"#存储器\"></a> 存储器</h3>\n<p>20 根地址线决定了寻址能力为 1MB，内存中基本单元为 1 个字节（8 位），线性顺序存放，两个字节组合为 1 个字（16 位），两个字组合为一个双字（32 位），在内存中可任意组合存放字节、字或双字：</p>\n<img src=\"/assets/images/buaa-x86/pic-2.png\" width=\"40%\" />\n<p>在内存中存放 1 个字时，低字节在前高字节在后；存放双字时，低字在前高字在后：</p>\n<img src=\"/assets/images/buaa-x86/pic-3.png\" width=\"35%\" />\n<p>用 16 位地址寄存器（指针）来表示地址时，最多可寻址 64KB，要表示 20 位地址需要对内存进行分段，每段最大 64KB，然后用一个寄存器（段寄存器）表示段地址，用另一个寄存器（指针寄存器）表示段内地址（偏移值）：</p>\n<ul>\n<li>物理地址：用 20 位二进制表示，且与内存单元一一对应的地址。</li>\n<li>逻辑地址：用段地址和偏移值组合来表示，常写成“段地址:偏移值”的形式。</li>\n</ul>\n<img src=\"/assets/images/buaa-x86/pic-4.png\" width=\"45%\" />\n<p>段地址乘 16 加偏移地址为物理地址，一个物理地址可能有多个逻辑地址的组合，典型的程序在内存中执行时，一般都有代码段、数据段、堆栈段，其段地址分别用 CS、DS、SS 来存放：</p>\n<img src=\"/assets/images/buaa-x86/pic-5.png\" width=\"30%\" />\n<p>堆栈是内存中由 SS 和 SP 确定的一块特殊的内存区域，它严格按照“先进后出”的方式工作：</p>\n<img src=\"/assets/images/buaa-x86/pic-6.png\" width=\"50%\" />\n<h2 id=\"寻址方式和指令系统\"><a class=\"markdownIt-Anchor\" href=\"#寻址方式和指令系统\"></a> 寻址方式和指令系统</h2>\n<h3 id=\"指令格式\"><a class=\"markdownIt-Anchor\" href=\"#指令格式\"></a> 指令格式</h3>\n<p>由“源”至“目的”，结果在目的操作数中，可以有 2 个，1 个，0 个操作数（指令编码的要素：操作码字节、寻址方式字节、段超越字节、操作数；指令长度由 1-7 个字节组成，变长指令编码），如下：</p>\n<pre class=\"highlight\"><code class=\"plain\">op &lt;- dst, src\n</code></pre>\n<h3 id=\"寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#寻址方式\"></a> 寻址方式</h3>\n<p>寻址方式即指令中寻找操作数的方式，包括：</p>\n<ul>\n<li>\n<p>与数据有关的 6 种寻址方式：</p>\n<ul>\n<li>\n<p>立即寻址：</p>\n<p>指令所需的操作数直接包含在指令代码中，通常为常量或常数，即立即数；立即数可以是 8 位的也可以是 16 位的，但需要与其对应的另一个操作数类型匹配。</p>\n</li>\n<li>\n<p>寄存器寻址：</p>\n<p>指令所需的操作数是 CPU 的某个寄存器，由于存取这类操作数完全在 CPU 内部进行，无需动用总线访问内存，所以执行速度比较快。对于 8 位操作数，寄存器可以是 AH、AL、BH、BL、CH、CL、DH、DL 中的任何一个，对于 16 位操作数，寄存器可以是 AX、BX、CX、DX、SP、BP、SI、DI、及 CS、DS、SS、ES 中的任何一个。操作数中的寄存器还可能是隐含的寄存器，例如 PUSHF 和 STD 等。</p>\n<p>在使用 CS、DS、SS、ES 时，必须满足指令要求即数据通路：</p>\n<img src=\"/assets/images/buaa-x86/pic-7.png\" width=\"60%\" />\n<p>由上图可知，如下类型的指令是合法的，其中 ac 为立即数，reg 为通用寄存器，segreg 为段寄存器，mem 为内存：</p>\n<img src=\"/assets/images/buaa-x86/pic-8.png\" width=\"60%\" />\n<p>使用段寄存器作为目的操作数时，不允许使用 CS 作为目的操作数。</p>\n</li>\n<li>\n<p>直接寻址：</p>\n<p>操作数的偏移地址直接在指令中指出的寻址方式，如果没有段超越，一般的取操作数都是相对于数据段 DS 的，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-number\">2000H</span>]\n</code></pre>\n<p>实际编程时，要知道每个操作数的偏移地址是很困难的，因为通常都使用变量（称为符号）来定义内存中的单元，例如如下两条伪指令分别定义字变量 X 和字节变量 C，这两个变量都在数据段定义：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X   <span class=\"hljs-built_in\">DW</span>    ?\nC   <span class=\"hljs-built_in\">DB</span>    <span class=\"hljs-string\">&#x27;A&#x27;</span>\n</code></pre>\n<p>如下指令的源操作数也是直接寻址方式，即汇编器会计算出 X 和 C 的偏移值，将它替换掉原来的 X 或 C，在 Debug 调试器下变量名消失，取而代之的是该变量在数据段中的偏移地址：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, X\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AL</span>, C\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AL</span>, C + <span class=\"hljs-number\">1</span>\n</code></pre>\n</li>\n<li>\n<p>寄存器间接寻址：</p>\n<p>操作数的有效地址不位于指令中，而是位于基址寄存器 BX 和 BP 或变址寄存器 SI 和 DI 中，因为地址未在指令中直接指出，而是通过一个寄存器来指明，因而称为间接寻址，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-built_in\">BX</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-number\">BH</span>, [<span class=\"hljs-built_in\">BP</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">CX</span>, [<span class=\"hljs-built_in\">SI</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DL</span>, [<span class=\"hljs-built_in\">DI</span>]\n</code></pre>\n<p>使用 BX、BP、SI、DI 作为寄存器进行间接寻址时，如果没有显式的指定段寄存器，则 BX、SI、DI 默认相对于 DS 段偏移，BP 默认相对于 SS 段偏移；需注意 SP 不可以用来间接寻址，即不能 SS:SP。</p>\n<p>指定段 SS:、DS:、CS:、ES：称段超越，即打破操作数的段缺省约定，转向指定的段来寻址，默认情况下：</p>\n<ul>\n<li>默认数据访问相对 DS。</li>\n<li>默认 BP 相对于 SS。</li>\n<li>默认转移相对于 CS。</li>\n<li>默认串指令的 DI 相对于 ES。</li>\n</ul>\n</li>\n<li>\n<p>寄存器相对寻址：</p>\n<p>操作数的有效地址是以一个基址寄存器或变址寄存器的内容和指令中指定的 8 位或 16 位位移量之和，实际上不过是在间接寻址的基础上加了一个常量，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-built_in\">SI</span> + <span class=\"hljs-number\">10H</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">10H</span>[<span class=\"hljs-built_in\">SI</span>]\n</code></pre>\n<p>同直接寻址一样，这种寻址方式的 16 位偏移量也可以是符号名或变量名，因为符号名和变量名在段内的位置（偏移值）实际上是固定的，所以它的作用等同于常量，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, ARRAY[<span class=\"hljs-built_in\">SI</span>]\n<span class=\"hljs-keyword\">MOV</span>     TABLE[<span class=\"hljs-built_in\">DI</span>], <span class=\"hljs-built_in\">AL</span>\n<span class=\"hljs-keyword\">MOV</span>     TABLE[<span class=\"hljs-built_in\">DI</span> + <span class=\"hljs-number\">1</span>], <span class=\"hljs-built_in\">AL</span>\n</code></pre>\n<p>上述第三条指令中，其经过汇编器汇编后，会将 TABLE + 1 的偏移值计算出来，在 Debug 调试器下看到的指令是如下形式：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     [<span class=\"hljs-built_in\">DI</span> + X], <span class=\"hljs-built_in\">AL</span>\n</code></pre>\n</li>\n<li>\n<p>基址变址寻址：</p>\n<p>操作数的有效地址等于一个基址寄存器和一个变址寄存器之和，这种寻址方式的最显著特点是两个寄存器均会出现在指令中，其中基址寄存器为 BX 或 BP，变址寄存器为 SI 或 DI；如果基址寄存器为 BX，则缺省时段寄存器为 DS，如果基址寄存器为 BP，则缺省时段寄存器为 SS，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-built_in\">BX</span>][<span class=\"hljs-built_in\">SI</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-built_in\">BX</span> + <span class=\"hljs-built_in\">SI</span>]\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">ES</span>:[<span class=\"hljs-built_in\">BX</span> + <span class=\"hljs-built_in\">SI</span>], <span class=\"hljs-built_in\">AL</span>\n<span class=\"hljs-keyword\">MOV</span>     [<span class=\"hljs-built_in\">BP</span> + <span class=\"hljs-built_in\">DI</span>], <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n<p>可以将基址变址寻址方式理解为在寄存器相对寻址方式上再加一个变址寄存器，以下指令中的操作数也是基址变址寻址方式：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, [<span class=\"hljs-built_in\">BX</span> + <span class=\"hljs-built_in\">SI</span> + <span class=\"hljs-number\">200</span>]\n<span class=\"hljs-keyword\">MOV</span>     ARRAY[<span class=\"hljs-built_in\">BP</span> + <span class=\"hljs-built_in\">SI</span>], <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>与转移指令有关的 4 种寻址方式：</p>\n<p>标号与过程名定义了代码段内的偏移值（直接）；对应地，变量定义了数据段和堆栈段内的偏移值。</p>\n<ul>\n<li>段内直接寻址：要转向的地址由当前 IP 与指令中的 8 位或 16 位位移量之和组成。</li>\n<li>段内间接寻址：要转向的偏移地址由一个寄存器或一个内存单元给出。</li>\n<li>段间直接寻址：在指令中直接给出了要转移至（CALL 指令或 JMP 指令）目标处的段地址和偏移地址。</li>\n<li>段间间接寻址：要转移的目标地址（CALL 指令或 JMP 指令长转移）由内存单元给出。</li>\n</ul>\n</li>\n<li>\n<p>与 I/O 有关的 2 种寻址方式：</p>\n<ul>\n<li>直接 I/O 端口寻址方式。</li>\n<li>寄存器 DX 间接寻址方式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指令集\"><a class=\"markdownIt-Anchor\" href=\"#指令集\"></a> 指令集</h3>\n<ul>\n<li>\n<p>操作数类型转换：</p>\n<p>有的时候仅凭符号名或变量名很难准确地知道内存操作数的类型，由于内存单元的基本单位是字节，所以不管变量是如何定义的，都可以进行类型转换。</p>\n<p>通过 BYTE PTR、WORD PTR、DWORD PTR 三个操作符，可以明确地指定内存操作数的类型，或进行强制类型转换：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BYTE</span> <span class=\"hljs-built_in\">PTR</span> X, <span class=\"hljs-built_in\">AL</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> [<span class=\"hljs-built_in\">DI</span>], <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n<li>\n<p>算术运算指令：</p>\n<ul>\n<li>\n<p>加减法指令（ADD、ADC、INC、SUB、SBB、DEC）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">ADD</span>     dst, src  <span class=\"hljs-comment\">; dst = dst + src，影响 CF、SF、ZF 等</span>\n<span class=\"hljs-keyword\">ADC</span>     dst, src  <span class=\"hljs-comment\">; dst = dst + src + CF，影响 CF、SF、ZF，带进位加</span>\n<span class=\"hljs-keyword\">INC</span>     opr       <span class=\"hljs-comment\">; opr = opr + 1，影响 CF、SF、ZF</span>\n<span class=\"hljs-keyword\">SUB</span>     dst, src  <span class=\"hljs-comment\">; dst = dst - src，影响 CF、SF、ZF 等</span>\n<span class=\"hljs-keyword\">SBB</span>     dst, src  <span class=\"hljs-comment\">; dst = dst - src - CF，影响 CF、SF、ZF，带借位减</span>\n<span class=\"hljs-keyword\">DEC</span>     opr       <span class=\"hljs-comment\">; opr = opr - 1，影响 CF、SF、ZF</span>\n</code></pre>\n<ul>\n<li>ZF 在运算结果为 0 时为 1，否则为 0。</li>\n<li>SF 为运算结果的最高位即符号位。</li>\n<li>CF 在存在进位或借位时为 1，否则为 0。</li>\n<li>OF 在发生溢出时为 1，否则为 0。</li>\n</ul>\n</li>\n<li>\n<p>比较与求补指令（CMP、NEG）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">CMP</span>     dst, src  <span class=\"hljs-comment\">; 与 SUB 类似，但不回送只产生标志位</span>\n<span class=\"hljs-keyword\">NEG</span>     opr       <span class=\"hljs-comment\">; opr = -opr</span>\n</code></pre>\n</li>\n<li>\n<p>乘法指令（MUL、IMUL、CBW，操作数 op 不能是立即数）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MUL</span>     op8   <span class=\"hljs-comment\">; AX = AL * op8，无符号乘法，</span>\n<span class=\"hljs-keyword\">MUL</span>     op16  <span class=\"hljs-comment\">; DX:AX = AX * op16，无符号乘法</span>\n<span class=\"hljs-keyword\">IMUL</span>    op8   <span class=\"hljs-comment\">; AX = AL * op8，带符号乘法</span>\n<span class=\"hljs-keyword\">IMUL</span>    op16  <span class=\"hljs-comment\">; DX:AX = AX * op16，带符号乘法</span>\n<span class=\"hljs-keyword\">CBW</span>           <span class=\"hljs-comment\">; 将 AL 的最高位（符号位）送 AH（00H 或 FFH）</span>\n</code></pre>\n</li>\n<li>\n<p>除法指令（DIV、IDIV、CWD，操作数 op 不能是立即数）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">DIV</span>     op8   <span class=\"hljs-comment\">; AX / op8 = AL，AX % op8 = AH，无符号除法</span>\n<span class=\"hljs-keyword\">DIV</span>     op16  <span class=\"hljs-comment\">; DX:AX / op16 = AX，DX:AX % op16 = DX，无符号除法</span>\n<span class=\"hljs-keyword\">IDIV</span>    op8   <span class=\"hljs-comment\">; AX / op8 = AL，AX % op8 = AH，带符号除法</span>\n<span class=\"hljs-keyword\">IDIV</span>    op16  <span class=\"hljs-comment\">; DX:AX / op16 = AX，DX:AX % op16 = DX，带符号除法</span>\n<span class=\"hljs-keyword\">CWD</span>           <span class=\"hljs-comment\">; 将 AX 的最高位（符号位）送 DX（0000H 或 FFFFH）</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>逻辑运算指令：</p>\n<ul>\n<li>\n<p>逻辑运算指令（AND、OR、XOR、NOT）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">AND</span>     dst, src\n<span class=\"hljs-keyword\">OR</span>      dst, src\n<span class=\"hljs-keyword\">XOR</span>     dst, src\n<span class=\"hljs-keyword\">NOT</span>     dst\n</code></pre>\n</li>\n<li>\n<p>测试指令（TEST）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">TEST</span>    dst, src  <span class=\"hljs-comment\">; 逻辑与，结果不回送</span>\n</code></pre>\n</li>\n<li>\n<p>移位指令（SHL、SHR、SAL、SAR、ROL、ROR、RCL、RCR，操作数 count 只能为 1 或 CL）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">SHL</span>     dst, count  <span class=\"hljs-comment\">; 逻辑左移</span>\n<span class=\"hljs-keyword\">SHR</span>     dst, count  <span class=\"hljs-comment\">; 逻辑右移</span>\n<span class=\"hljs-keyword\">SAL</span>     dst, count  <span class=\"hljs-comment\">; 算术左移</span>\n<span class=\"hljs-keyword\">SAR</span>     dst, count  <span class=\"hljs-comment\">; 算术右移</span>\n<span class=\"hljs-keyword\">ROL</span>     dst, count  <span class=\"hljs-comment\">; 循环左移</span>\n<span class=\"hljs-keyword\">ROR</span>     dst, count  <span class=\"hljs-comment\">; 循环右移</span>\n<span class=\"hljs-keyword\">RCL</span>     dst, count  <span class=\"hljs-comment\">; 带进位循环左移</span>\n<span class=\"hljs-keyword\">RCR</span>     dst, count  <span class=\"hljs-comment\">; 带进位循环右移</span>\n</code></pre>\n<img src=\"/assets/images/buaa-x86/pic-9.png\" width=\"80%\" />\n</li>\n</ul>\n</li>\n<li>\n<p>条件转移指令：</p>\n<ul>\n<li>\n<p>无条件转移（JMP，不能写 <code>JMP WORD PTR BX</code>，而是 <code>JMP BX</code>；可以写 <code>JMP WORD PTR [BX]</code>，也可以 <code>JMP [BX]</code>）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">JMP</span>     SHORT 标号                 <span class=\"hljs-comment\">; 段内直接短转移，此处不能有 PTR</span>\n<span class=\"hljs-keyword\">JMP</span>     <span class=\"hljs-built_in\">NEAR</span> <span class=\"hljs-built_in\">PTR</span> 标号              <span class=\"hljs-comment\">; 段内直接转移</span>\n<span class=\"hljs-keyword\">JMP</span>     <span class=\"hljs-built_in\">FAR</span> <span class=\"hljs-built_in\">PTR</span> 标号               <span class=\"hljs-comment\">; 段间直接转移</span>\n<span class=\"hljs-keyword\">JMP</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> 寄存器或内存单元   <span class=\"hljs-comment\">; 段内间接转移</span>\n<span class=\"hljs-keyword\">JMP</span>     <span class=\"hljs-built_in\">DWORD</span> <span class=\"hljs-built_in\">PTR</span> 寄存器或内存单元  <span class=\"hljs-comment\">; 段间间接转移</span>\n</code></pre>\n</li>\n<li>\n<p>无符号数比较后转移（JA、JB、JE）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">JA</span>      dst  <span class=\"hljs-comment\">; 高于或不低于不等于时转移，等价于 JNBE</span>\n<span class=\"hljs-keyword\">JAE</span>     dst  <span class=\"hljs-comment\">; 高于等于或不低于时转移，等价于 JNB</span>\n<span class=\"hljs-keyword\">JB</span>      dst  <span class=\"hljs-comment\">; 低于或不高于不等于时转移，等价于 JNAE</span>\n<span class=\"hljs-keyword\">JBE</span>     dst  <span class=\"hljs-comment\">; 低于等于或不高于时转移，等价于 JNA</span>\n<span class=\"hljs-keyword\">JE</span>      dst  <span class=\"hljs-comment\">; 等于或结果为 0 时转移，等价于 JZ</span>\n<span class=\"hljs-keyword\">JNE</span>     dst  <span class=\"hljs-comment\">; 不等于或结果不为 0 时转移，等价于 JNZ</span>\n</code></pre>\n</li>\n<li>\n<p>有符号数比较后转移（JG、JL、JE）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">JG</span>      dst  <span class=\"hljs-comment\">; 高于或不低于不等于时转移，等价于 JNLE</span>\n<span class=\"hljs-keyword\">JGE</span>     dst  <span class=\"hljs-comment\">; 高于等于或不低于时转移，等价于 JNL</span>\n<span class=\"hljs-keyword\">JL</span>      dst  <span class=\"hljs-comment\">; 低于或不高于不等于时转移，等价于 JNGE</span>\n<span class=\"hljs-keyword\">JLE</span>     dst  <span class=\"hljs-comment\">; 低于等于或不高于时转移，等价于 JNG</span>\n<span class=\"hljs-keyword\">JE</span>      dst  <span class=\"hljs-comment\">; 等于或结果为 0 时转移，等价于 JZ</span>\n<span class=\"hljs-keyword\">JNE</span>     dst  <span class=\"hljs-comment\">; 不等于或结果不为 0 时转移，等价于 JNZ</span>\n</code></pre>\n</li>\n<li>\n<p>循环指令（LOOP、LOOPZ、LOOPNZ、JCXZ）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">LOOP</span>    dst  <span class=\"hljs-comment\">; 先 CX - 1，CX 不为 0 时转移</span>\n<span class=\"hljs-keyword\">LOOPZ</span>   dst  <span class=\"hljs-comment\">; 先 CX - 1，CX 不为 0 且 ZF 为 0 时转移</span>\n<span class=\"hljs-keyword\">LOOPNZ</span>  dst  <span class=\"hljs-comment\">; 先 CX - 1，CX 不为 0 且 ZF 不为 0 时转移</span>\n<span class=\"hljs-keyword\">JCXZ</span>    dst  <span class=\"hljs-comment\">; 不执行 CX - 1，CX 为 0 时转移</span>\n</code></pre>\n</li>\n<li>\n<p>子程序相关指令（CALL、RET）：</p>\n<p>CALL 指令：</p>\n<img src=\"/assets/images/buaa-x86/pic-10.png\" width=\"55%\" />\n<p>RET 指令：</p>\n<img src=\"/assets/images/buaa-x86/pic-11.png\" width=\"45%\" />\n<p>子程序的定义：</p>\n<ul>\n<li>如果调用指令和所定义的过程位于同一代码段中，则定义为 NEAR 属性并可以省略 NEAR。</li>\n<li>如果调用指令和所定义的过程位于不同的代码段中，则定义为 FAR 属性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>串操作指令：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">LODSB</span>   <span class=\"hljs-comment\">; 取字节，SI 自动加减 1</span>\n<span class=\"hljs-keyword\">LODSW</span>   <span class=\"hljs-comment\">; 取字，SI 自动加减 2</span>\n\n<span class=\"hljs-keyword\">STOSB</span>   <span class=\"hljs-comment\">; 存字节，DI 自动加减 1</span>\n<span class=\"hljs-keyword\">STOSW</span>   <span class=\"hljs-comment\">; 存字，DI 自动加减 2</span>\n\n<span class=\"hljs-keyword\">MOVSB</span>   <span class=\"hljs-comment\">; 传字节，SI, DI 自动加减 1</span>\n<span class=\"hljs-keyword\">MOVSW</span>   <span class=\"hljs-comment\">; 传字，SI, DI 自动加减 2</span>\n\n<span class=\"hljs-keyword\">CMPSB</span>   <span class=\"hljs-comment\">; 比较字节，等价于 CMP DS:[SI], ES:[DI]</span>\n<span class=\"hljs-keyword\">CMPSW</span>   <span class=\"hljs-comment\">; 比较字，等价于 CMP DS:[SI], ES:[DI]</span>\n\n<span class=\"hljs-keyword\">SCASB</span>   <span class=\"hljs-comment\">; 扫描字节，等价于 CMP AL, ES:[DI]</span>\n<span class=\"hljs-keyword\">SCASW</span>   <span class=\"hljs-comment\">; 扫描字，等价于 CMP AX, ES:[DI]</span>\n\n<span class=\"hljs-keyword\">REP</span>     串操作指令  <span class=\"hljs-comment\">; 重复前缀，每执行一次串操作 CX 减 1，直到 CX 为 0</span>\n<span class=\"hljs-keyword\">REPE</span>    串操作指令  <span class=\"hljs-comment\">; 条件重复前缀，CX 非 0 且 ZF 为 1 时执行串操作，然后 CX 减 1，等价于 REPZ</span>\n<span class=\"hljs-keyword\">REPNE</span>   串操作指令  <span class=\"hljs-comment\">; 条件重复前缀，CX 非 0 且 ZF 为 0 时执行串操作，然后 CX 减 1，等价于 REPNZ</span>\n</code></pre>\n<p>串操作隐含的是相对于 DS 及 ES 段的 SI 和 DI 间接寻址，典型寻址过程是：</p>\n<pre class=\"highlight\"><code class=\"plain\">DS:[SI] -&gt; ES:[DI]\n</code></pre>\n<p>使用串操作指令：</p>\n<ul>\n<li>根据需要设置 DS、SI、ES、DI。</li>\n<li>设置 DF 标志，DF 为 0 时 SI 和 DI 增加，DF 为 1 时 SI 和 DI 减小。</li>\n<li>设置 CX 值。</li>\n<li>选用 REP、REPE、REPZ、REPNE、REPNZ。</li>\n</ul>\n</li>\n<li>\n<p>堆栈指令：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">PUSH</span>    src  <span class=\"hljs-comment\">; SP = SP - 2, SS:[SP] = src</span>\n<span class=\"hljs-keyword\">PUSHF</span>        <span class=\"hljs-comment\">; SP = SP - 2, SS:[SP] = PSW</span>\n<span class=\"hljs-keyword\">POP</span>     dst  <span class=\"hljs-comment\">; dst = SS:[SP], SP = SP + 2</span>\n<span class=\"hljs-keyword\">POPF</span>         <span class=\"hljs-comment\">; PSW = SS:[SP], SP = SP + 2</span>\n</code></pre>\n</li>\n<li>\n<p>LEA、LDS、LES 指令：</p>\n<p>LEA 指令获取的是 src 的偏移地址，而不是内容；LDS 是将 src 的双字取出，将低字（在前面）送入 src，将高字（在后面）送入 DS 寄存器，src 处保存的双字一般都是某个程序或变量的逻辑地址（seg:offset）；LES 的作用于 LDS 类似，只是使用的是 ES 寄存器：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">LEA</span>     reg, src  <span class=\"hljs-comment\">; 将 src 的偏移地址送入 reg 中</span>\n<span class=\"hljs-keyword\">LDS</span>     reg, src  <span class=\"hljs-comment\">; 将 src 中的双字内容依次送入 reg 及 DS 中</span>\n<span class=\"hljs-keyword\">LES</span>     reg, src  <span class=\"hljs-comment\">; 将 src 中的双字内容依次送入 reg 及 ES 中</span>\n</code></pre>\n<p>另有两个操作符 OFFSET 和 SEG 也可用于获取地址，如下：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BX</span>, OFFSET X  <span class=\"hljs-comment\">; 获取 X 的偏移地址，等价于 LEA BX, X</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">SEG</span> X     <span class=\"hljs-comment\">; 获取 X 的段地址，等价于 MOV AX, DS</span>\n</code></pre>\n</li>\n<li>\n<p>其它指令：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">XCHG</span>    opr1, opr2  <span class=\"hljs-comment\">; 两个操作数的内容互换，不允许任何一个操作数使用立即数</span>\n<span class=\"hljs-keyword\">CLC</span>                 <span class=\"hljs-comment\">; CF = 0</span>\n<span class=\"hljs-keyword\">STC</span>                 <span class=\"hljs-comment\">; CF = 1</span>\n<span class=\"hljs-keyword\">CMC</span>                 <span class=\"hljs-comment\">; CF = CF ^ 1，即取反</span>\n<span class=\"hljs-keyword\">CLD</span>                 <span class=\"hljs-comment\">; DF = 0</span>\n<span class=\"hljs-keyword\">STD</span>                 <span class=\"hljs-comment\">; DF = 1</span>\n<span class=\"hljs-keyword\">CLI</span>                 <span class=\"hljs-comment\">; IP = 0</span>\n<span class=\"hljs-keyword\">STI</span>                 <span class=\"hljs-comment\">; IP = 1</span>\n<span class=\"hljs-keyword\">NOP</span>                 <span class=\"hljs-comment\">; 无操作，消耗一个周期</span>\n<span class=\"hljs-keyword\">HLT</span>                 <span class=\"hljs-comment\">; 停机</span>\nWAIT                <span class=\"hljs-comment\">; 等待</span>\nESC     mem         <span class=\"hljs-comment\">; 换码</span>\n<span class=\"hljs-keyword\">LOCK</span>                <span class=\"hljs-comment\">; 封锁指令</span>\n</code></pre>\n</li>\n</ul>\n<h3 id=\"指令示例\"><a class=\"markdownIt-Anchor\" href=\"#指令示例\"></a> 指令示例</h3>\n<p>传送指令示例：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X1      <span class=\"hljs-built_in\">DB</span>      <span class=\"hljs-string\">&#x27;1&#x27;</span>\nX2      <span class=\"hljs-built_in\">DD</span>      <span class=\"hljs-number\">12345678H</span>\nX3      <span class=\"hljs-built_in\">DD</span>      ?\n</code></pre>\n<ul>\n<li>\n<p>将 X2 传送到 X3 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DI</span>, OFFSET X3\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X2\n<span class=\"hljs-keyword\">MOV</span>     [<span class=\"hljs-built_in\">DI</span>], <span class=\"hljs-built_in\">AX</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X2 + <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">MOV</span>     [<span class=\"hljs-built_in\">DI</span> + <span class=\"hljs-number\">2</span>], <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n<li>\n<p>将 X1 传送到 X3 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AL</span>, X1\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BYTE</span> <span class=\"hljs-built_in\">PTR</span> X3, <span class=\"hljs-built_in\">AL</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BYTE</span> <span class=\"hljs-built_in\">PTR</span> X3 + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X3 + <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>\n</code></pre>\n</li>\n</ul>\n<p>32 位加减法示例：</p>\n<ul>\n<li>\n<p>32 位加法可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X       <span class=\"hljs-built_in\">DW</span>      ?\nY       <span class=\"hljs-built_in\">DW</span>      ?\nZ       <span class=\"hljs-built_in\">DD</span>      ?\n</code></pre>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, X\n<span class=\"hljs-keyword\">ADD</span>     <span class=\"hljs-built_in\">AX</span>, Y\n<span class=\"hljs-keyword\">ADC</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Z, <span class=\"hljs-built_in\">AX</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Z + <span class=\"hljs-number\">2</span>, <span class=\"hljs-built_in\">DX</span>\n</code></pre>\n</li>\n<li>\n<p>32 位减法可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X       <span class=\"hljs-built_in\">DD</span>      ?\nY       <span class=\"hljs-built_in\">DD</span>      ?\nZ       <span class=\"hljs-built_in\">DD</span>      ?\n</code></pre>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X + <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X\n<span class=\"hljs-keyword\">SUB</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Y\n<span class=\"hljs-keyword\">SBB</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Y + <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Z, <span class=\"hljs-built_in\">AX</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> Z + <span class=\"hljs-number\">2</span>, <span class=\"hljs-built_in\">DX</span>\n</code></pre>\n</li>\n</ul>\n<p>乘除法示例：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X       <span class=\"hljs-built_in\">DW</span>      ?\nY       <span class=\"hljs-built_in\">DW</span>      ?\n</code></pre>\n<ul>\n<li>\n<p>计算 X 乘 10 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, X\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BX</span>, <span class=\"hljs-number\">10</span>\n<span class=\"hljs-keyword\">MUL</span>     <span class=\"hljs-built_in\">BX</span>\n<span class=\"hljs-keyword\">MOV</span>     Y, <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n<li>\n<p>计算 Y 除 10 可以为（需要按 16 位处理，否则可能溢出）：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, Y\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BX</span>, <span class=\"hljs-number\">10</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">DIV</span>     <span class=\"hljs-built_in\">BX</span>\n<span class=\"hljs-keyword\">MOV</span>     X, <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n</ul>\n<p>移位指令示例：</p>\n<ul>\n<li>\n<p>计算 X 乘 10 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X       <span class=\"hljs-built_in\">DW</span>      ?\n</code></pre>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">BX</span>, X\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">BX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">BX</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">BX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">BX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">AX</span>\n<span class=\"hljs-keyword\">ADD</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">BX</span>\n<span class=\"hljs-keyword\">MOV</span>     X, <span class=\"hljs-built_in\">AX</span>\n</code></pre>\n</li>\n<li>\n<p>计算 X 乘 16 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">X       <span class=\"hljs-built_in\">DD</span>      ?\n</code></pre>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-built_in\">WORD</span> <span class=\"hljs-built_in\">PTR</span> X + <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">RCL</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">RCL</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">RCL</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">SHL</span>     <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">RCL</span>     <span class=\"hljs-built_in\">DX</span>, <span class=\"hljs-number\">1</span>\n</code></pre>\n</li>\n</ul>\n<p>串操作指令示例：</p>\n<ul>\n<li>\n<p>传送缓冲区内容可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">DS</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">SI</span>, OFFSET BUFF1\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DI</span>, OFFSET BUFF2\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">CX</span>, LEN\n<span class=\"hljs-keyword\">CLD</span>\n<span class=\"hljs-keyword\">REP</span>     <span class=\"hljs-keyword\">MOVSB</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n</code></pre>\n</li>\n<li>\n<p>清零缓冲区可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">DS</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DI</span>, OFFSET BUFF\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">CX</span>, LEN\n<span class=\"hljs-keyword\">CLD</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AL</span>, <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">REP</span>     <span class=\"hljs-keyword\">STOSB</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n</code></pre>\n</li>\n<li>\n<p>缓冲区小写转大写可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">        <span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">ES</span>\n        <span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">DS</span>\n        <span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n        <span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">SI</span>, OFFSET BUFF\n        <span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DI</span>, <span class=\"hljs-built_in\">SI</span>\n        <span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">CX</span>, LEN\n        <span class=\"hljs-keyword\">CLD</span>\n<span class=\"hljs-symbol\">LP1:</span>    <span class=\"hljs-keyword\">LODSB</span>\n        <span class=\"hljs-keyword\">CMP</span>     <span class=\"hljs-built_in\">AL</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>\n        <span class=\"hljs-keyword\">JB</span>      NEXT\n        <span class=\"hljs-keyword\">CMP</span>     <span class=\"hljs-built_in\">AL</span>, <span class=\"hljs-string\">&#x27;z&#x27;</span>\n        <span class=\"hljs-keyword\">JA</span>      NEXT\n        <span class=\"hljs-keyword\">SUB</span>     <span class=\"hljs-built_in\">AL</span>, <span class=\"hljs-number\">20H</span>\n<span class=\"hljs-symbol\">NEXT:</span>   <span class=\"hljs-keyword\">STOSB</span>\n        <span class=\"hljs-keyword\">LOOP</span>    LP1\n        <span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n</code></pre>\n</li>\n<li>\n<p>扫描缓冲区查找字母 A 可以为：</p>\n<pre class=\"highlight\"><code class=\"x86asm\"><span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">PUSH</span>    <span class=\"hljs-built_in\">DS</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">DI</span>, OFFSET BUFF\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">CX</span>, LEN\n<span class=\"hljs-keyword\">CLD</span>\n<span class=\"hljs-keyword\">MOV</span>     <span class=\"hljs-built_in\">AL</span>, <span class=\"hljs-string\">&#x27;A&#x27;</span>\n<span class=\"hljs-keyword\">REPNZ</span>   <span class=\"hljs-keyword\">SCASB</span>\n<span class=\"hljs-keyword\">JZ</span>      FOUND\n<span class=\"hljs-comment\">; ......</span>\n<span class=\"hljs-keyword\">POP</span>     <span class=\"hljs-built_in\">ES</span>\n</code></pre>\n</li>\n</ul>\n<h2 id=\"汇编语言程序格式\"><a class=\"markdownIt-Anchor\" href=\"#汇编语言程序格式\"></a> 汇编语言程序格式</h2>\n<h3 id=\"三段式程序结构\"><a class=\"markdownIt-Anchor\" href=\"#三段式程序结构\"></a> 三段式程序结构</h3>\n<p>三列格式：</p>\n<ul>\n<li>标号（符号或变量，不区分大小写，变成逻辑地址即立即数）。</li>\n<li>指令或伪指令（助记符）。</li>\n<li>操作数，分号后是注释。</li>\n</ul>\n<p>堆栈段示例：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">STACK       <span class=\"hljs-meta\">SEGMENT</span>     PARA STACK\nSTACK_AREA  <span class=\"hljs-built_in\">DW</span>          <span class=\"hljs-number\">100h</span> DUP(?)\nSTACK_TOP   <span class=\"hljs-built_in\">EQU</span>         $ - STACK_AREA\nSTACK       ENDS\n</code></pre>\n<p>数据段示例：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">DATA        <span class=\"hljs-meta\">SEGMENT</span>     PARA\nTABLE_LEN   <span class=\"hljs-built_in\">DW</span>          <span class=\"hljs-number\">16</span>\nTABLE       <span class=\"hljs-built_in\">DW</span>          <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>\n            <span class=\"hljs-built_in\">DW</span>          <span class=\"hljs-number\">41H</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">42H</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">60</span>, <span class=\"hljs-number\">0FFFFH</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>\nDATA        ENDS\n</code></pre>\n<p>代码段示例：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">CODE        <span class=\"hljs-meta\">SEGMENT</span>     PARA\n            <span class=\"hljs-meta\">ASSUME</span>      <span class=\"hljs-built_in\">CS</span>:CODE, <span class=\"hljs-built_in\">DS</span>:DATA, <span class=\"hljs-built_in\">SS</span>:STACK\n\nMAIN        PROC        <span class=\"hljs-built_in\">FAR</span>\n<span class=\"hljs-symbol\">START:</span>      <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">AX</span>, STACK\n            <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">SS</span>, <span class=\"hljs-built_in\">AX</span>\n            <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">SP</span>, STACK_TOP\n            <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">AX</span>, DATA\n            <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">DS</span>, <span class=\"hljs-built_in\">AX</span>\n            <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">ES</span>, <span class=\"hljs-built_in\">AX</span>\n\n            <span class=\"hljs-comment\">; ......</span>\n<span class=\"hljs-symbol\">\nEXIT:</span>       <span class=\"hljs-keyword\">MOV</span>         <span class=\"hljs-built_in\">AX</span>, <span class=\"hljs-number\">4C00H</span>\n            <span class=\"hljs-keyword\">INT</span>         <span class=\"hljs-number\">21H</span>\nMAIN        ENDP\nCODE        ENDS\n            END         MAIN\n</code></pre>\n<h3 id=\"定义段的伪指令\"><a class=\"markdownIt-Anchor\" href=\"#定义段的伪指令\"></a> 定义段的伪指令</h3>\n<img src=\"/assets/images/buaa-x86/pic-12.png\" width=\"60%\" />\n<p>对齐类型是一个可选字段，它定义了段在内存中分配时的起始边界设定（段和段之间的空隙），可选择的参数包括：</p>\n<ul>\n<li>PAGE（页）：表示本段从页的边界开始，一页为 256 字节，所以段的起始地址（段基地址）的低 8 位为 0，采用 PAGE 方式对齐时，段与段之间最大的空隙可能为 255 字节。</li>\n<li>PARA（节）：表示本段从节的边界开始，一节为 16 字节，所以段的起始地址的低 4 位为 0，采用此种对齐方式，段内偏移值可以从 0 开始，SEGMENT 的缺省对位类型是 PARA，故一般省略此参数，采用 PARA 对齐时，段与段之间最大可能空隙是 15 字节。</li>\n<li>WORD（字）：表示本段从内存中的偶字节地址开始，段与段之间的空隙最多只有 1 字节。</li>\n<li>BYTE（字节）：表示本段从字节地址开始，段与段之间无任何空隙。</li>\n</ul>\n<p>组合类型参数用于确定段和段之间的关系，当程序有多个模块时（或多个数据段和代码段）以及有特殊要求时，可通过组合类型来确定各段之间段的组合方式：</p>\n<ul>\n<li>STACK：说明该段为堆栈段的一部分，连接程序在连接时，会把所有同名的具有 STACK 组合类型的段连接成一个连续段，并将 SS 初始化成这个连续段的首地址，用段内的最大偏移地址初始化 SP，正确地定义了段的 STACK 属性后，可以在主程序中省略对 SS 和 SP 的初始化。</li>\n</ul>\n<h3 id=\"数据定义伪指令及相关操作符\"><a class=\"markdownIt-Anchor\" href=\"#数据定义伪指令及相关操作符\"></a> 数据定义伪指令及相关操作符</h3>\n<ul>\n<li>\n<p>数据定义的伪指令：</p>\n<p>DB、DW、DD 定义变量；EQU 定义常量（不占内存，被汇编变成值）。</p>\n<img src=\"/assets/images/buaa-x86/pic-13.png\" width=\"95%\" />\n<p>数据定义的表达式：</p>\n<ul>\n<li>$：当前位置计数器（表达式）。</li>\n<li>DUP：重复操作符。</li>\n<li>?：表达式，表示不预置任何内容。</li>\n<li>字符串表达式。</li>\n<li>地址表达式。</li>\n</ul>\n<p>$ 是一个很特殊的当前位置计数器，代表的是当前的偏移值，这个计数器在代码段，数据段及堆栈段中都有效，最常见的用途是计算长度，例如可以如下计算一个数组的长度：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">TABLE       <span class=\"hljs-built_in\">DW</span>      <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, .....\nTABLE_LEN   <span class=\"hljs-built_in\">EQU</span>     $ - TABLE\n</code></pre>\n</li>\n<li>\n<p>数组定义：</p>\n<p>可如下定义一维或二维数组：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">ARRAY1  <span class=\"hljs-built_in\">DB</span>      <span class=\"hljs-number\">2</span> DUP (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0FFH</span>, ?)  <span class=\"hljs-comment\">; 定义一个简单的二维数组</span>\nARRAY2  <span class=\"hljs-built_in\">DB</span>      <span class=\"hljs-number\">100</span> DUP (?)            <span class=\"hljs-comment\">; 定义一个一维数组</span>\n</code></pre>\n<img src=\"/assets/images/buaa-x86/pic-14.png\" width=\"35%\" />\n<p>DUP 可以嵌套，相当于多维数组，例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">ARRAY3  <span class=\"hljs-built_in\">DB</span>      <span class=\"hljs-number\">2</span> DUP (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, DUP(<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>), <span class=\"hljs-number\">0</span>)\n</code></pre>\n<img src=\"/assets/images/buaa-x86/pic-15.png\" width=\"30%\" />\n</li>\n<li>\n<p>字符串表达式：</p>\n<p>字符串表达式是为变量分配单元并指定其初始值为字符的 ASCII 码（对于 DW 和 DD 伪指令，不允许使用两个以上字符的字符串作为其参数；DOS 功能 9 显示的字符串，用 $ 结尾，一般用 00H 结尾），例如：</p>\n<pre class=\"highlight\"><code class=\"x86asm\">STRING  <span class=\"hljs-built_in\">DB</span>      <span class=\"hljs-string\">&#x27;ABCD&#x27;</span>, <span class=\"hljs-number\">0DH</span>, <span class=\"hljs-number\">0AH</span>, <span class=\"hljs-string\">&#x27;$&#x27;</span>\nSTRING  <span class=\"hljs-built_in\">DW</span>      <span class=\"hljs-string\">&#x27;AB&#x27;</span>, <span class=\"hljs-string\">&#x27;CD&#x27;</span>\n</code></pre>\n</li>\n<li>\n<p>地址表达式：</p>\n<p>在定义数据时，还可以使用 DW 或 DD 伪指令把标号或变量的偏移地址或整个逻辑地址存入到另一个变量中，使用 DD 来存储逻辑地址时，第一个字（低字）为偏移地址，第二个字（高字）为段地址，此处的参数实际上是一个地址表达式。</p>\n<img src=\"/assets/images/buaa-x86/pic-16.png\" width=\"65%\" />\n</li>\n</ul>\n<h3 id=\"过程定义伪指令及相关操作符\"><a class=\"markdownIt-Anchor\" href=\"#过程定义伪指令及相关操作符\"></a> 过程定义伪指令及相关操作符</h3>\n<ul>\n<li>\n<p>PROC、ENDP 标号：</p>\n<img src=\"/assets/images/buaa-x86/pic-17.png\" width=\"80%\" />\n<p>当过程定义为 NEAR 时，RET 指令在汇编后仍为 RET，属于段内返回，它从堆栈中弹出一个字作为 IP 值；当过程定义为 FAR 时，RET 指令在汇编后变成了 RETF，属于段间返回，它从堆栈中先后弹出两个字作为 IP 值和 CS 值。</p>\n</li>\n<li>\n<p>END 标号：</p>\n<p>程序总结束，标号为入口，被汇编设置为初始的 CS:IP。</p>\n</li>\n<li>\n<p>MACRO、ENDM 标号：</p>\n<p>定义宏，实际上是代码替换。</p>\n</li>\n</ul>\n<h3 id=\"masm-环境\"><a class=\"markdownIt-Anchor\" href=\"#masm-环境\"></a> MASM 环境</h3>\n<ul>\n<li>\n<p>主要命令：</p>\n<ul>\n<li><code>EDIT XXXX.asm</code>：编辑源程序。</li>\n<li><code>MASM XXXX.asm</code>：汇编 ASM 文件，生成 OBJ、LST、CRF 文件。LST 文件可看到汇编是如何翻译的：变量、符号、标号、子程序名、初值、偏移值。</li>\n<li><code>LINK XXXX.obj</code>：连接 OBJ 文件，生成 MAP 和 EXE 文件。MAP 文件可以看到内存图：三个段的长度、程序入口即初始 CS:IP、对齐类型 PARA。</li>\n<li><code>DEBUG XXXX.exe</code>：调试执行 EXE 文件。</li>\n</ul>\n</li>\n<li>\n<p>调试执行：</p>\n<ul>\n<li>d：显示内存单元的内容。</li>\n<li>e：修改内存单元的内容。</li>\n<li>r：显示或修改寄存器的内容，可修改 IP 以修改执行点。</li>\n<li>f：填写内存单元（批量修改）。</li>\n<li>t：单步跟踪命令，进入子程序、循环、功能调用。</li>\n<li>p：单步执行命令，执行完子程序、循环、功能调用。</li>\n<li>g：运行命令，执行到某个指令（地址处）。</li>\n<li>u：反汇编命令，用于查看内存中的程序。</li>\n<li>a：汇编命令，用于直接在内存中输入指令序列。</li>\n<li>n：命名文件，指定文件名。</li>\n<li>l：装入文件。</li>\n<li>w：写回文件。</li>\n<li>q：退出 Debug。</li>\n</ul>\n</li>\n</ul>\n","length":"5.8k","time":"23min","categories":["Buaa","X86"],"tags":["Assembly","Architecture"]}