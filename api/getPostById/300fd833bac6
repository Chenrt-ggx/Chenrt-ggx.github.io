{"id":"300fd833bac6","title":"不基于验证码的脚本检测及应对方式","created":"2023-02-15T12:21:02.000Z","updated":"2023-02-16T04:13:51.000Z","raw":"<p>仅笔者想到的基于 Web 的一些方式，欢迎补充。另外，又到了选课的季节啊（逃</p>\n<span id=\"more\"></span>\n<p>一些 Web 服务的维护者不希望用户通过脚本访问他们的服务，虽然大部分这样的维护者可以通过验证码的方式解决这个问题，但总有少数这样的维护者面对开发者跑路自己不会添加验证码机制，或者系统的架构过于优美加上验证码机制真的会死的情况。本文主要探讨 Web 服务如何不基于验证码检测脚本，以及脚本的开发者如何应对。</p>\n<h2 id=\"被动检测\"><a class=\"markdownIt-Anchor\" href=\"#被动检测\"></a> 被动检测</h2>\n<h3 id=\"基于静态资源\"><a class=\"markdownIt-Anchor\" href=\"#基于静态资源\"></a> 基于静态资源</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>正常用户在通过浏览器访问网页时，客户端与服务端会经过客户端请求 HTML 页面、客户端基于得到的 HTML 页面加载以 CSS 和 JS 为代表的静态资源、客户端完成渲染，用户开始操作的过程，而在通过脚本直接访问服务时，可能不需要请求 HTML 页面或请求静态资源即可直接模拟用户操作，通过分析请求静态资源的频率可以一定程度进行区分。</p>\n<p>由于浏览器缓存策略和用户操作习惯（清理缓存、多开页面、浏览器选择等）的玄学性，这种方式存在较高的误判率，可能需要结合其它方式判断。</p>\n</li>\n<li>\n<p>应对方法</p>\n<p>模拟请求 HTML 页面，再解析 HTML 页面（有很多 XML 的轮子）请求静态资源，需要关注的标签包括：</p>\n<pre class=\"highlight\"><code class=\"js\">&lt;script src=<span class=\"hljs-string\">&quot;xxx&quot;</span>&gt;&lt;/script&gt;\n</code></pre>\n<pre class=\"highlight\"><code class=\"js\">&lt;link href=<span class=\"hljs-string\">&quot;xxx&quot;</span>&gt;&lt;/link&gt;\n</code></pre>\n<p>这种方式可以解决绝大多数静态资源，但无法请求 JS 中加载的静态资源，不过由于检测原理的准确性较差，不请求 JS 中加载的静态资源一般问题不大。</p>\n</li>\n</ul>\n<h3 id=\"基于-api-访问\"><a class=\"markdownIt-Anchor\" href=\"#基于-api-访问\"></a> 基于 API 访问</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>在前后端分离的项目中，页面的渲染过程中往往存在 created 阶段和 mounted 阶段，这些阶段中可能存在请求某个或某些 API 的情况。正常用户在通过浏览器访问网页时，相应 API 会被请求，而通过脚本直接访问服务时，可能没这些 API 什么事，通过分析访问 API 的频率可以一定程度进行区分。</p>\n<p>由于用户操作习惯（清理缓存、多开页面、浏览器选择等）的玄学性，这种方式存在较高的误判率，可能需要结合其它方式判断。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>抓包或者 F12 分析一下请求行为，然后模拟在 created 阶段和 mounted 阶段的 API 访问。</p>\n</li>\n</ul>\n<h3 id=\"基于请求体\"><a class=\"markdownIt-Anchor\" href=\"#基于请求体\"></a> 基于请求体</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>在请求体中，可能存在若干似乎无用的字段。正常用户在操作时，这些字段由前端填充，而脚本的开发者可能不会注意这些细节，直接删除这些字段或在这些字段采用固定值，这些字段缺失或错误的大概率就是脚本。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>逆向前端，分析每个字段的来源，按照相同的规则填写各个字段即可。</p>\n</li>\n</ul>\n<h3 id=\"基于请求头\"><a class=\"markdownIt-Anchor\" href=\"#基于请求头\"></a> 基于请求头</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>在请求头中，可能存在若干似乎无用的字段。正常用户在操作时，这些字段由浏览器或前端填充，而脚本的开发者可能不会注意这些细节，直接删除这些字段或在这些字段采用固定值，由浏览器填充的字段缺失则可能是脚本，由前端的填充的字段缺失或错误则大概率就是脚本。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>对于由前端的填充的字段，逆向前端，分析每个字段的来源，按照相同的规则填写各个字段即可。对于由浏览器填充的字段，需要脚本的开发者人工（结合浏览器开发者工具或抓包）维护，常见的一些字段如下：</p>\n<ul>\n<li>\n<p>Accept 字段，普遍存在，对静态资源和其它资源（不同浏览器存在差异，不必过于严格）依次如下：</p>\n<pre class=\"highlight\"><code class=\"plain\">Accept: */*\n</code></pre>\n<pre class=\"highlight\"><code class=\"plain\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\n</code></pre>\n</li>\n<li>\n<p>Accept-Language 字段，普遍存在，一般写死即可：</p>\n<pre class=\"highlight\"><code class=\"plain\">Accept-Language: zh-CN,zh;q=0.9\n</code></pre>\n</li>\n<li>\n<p>Accept-Encoding 字段，普遍存在，一般写死即可：</p>\n<pre class=\"highlight\"><code class=\"plain\">Accept-Encoding: gzip, deflate, br\n</code></pre>\n</li>\n<li>\n<p>Connection 字段，普遍存在，一般写死即可：</p>\n<pre class=\"highlight\"><code class=\"plain\">Connection: keep-alive\n</code></pre>\n</li>\n<li>\n<p>User-Agent 字段，普遍存在，有较多选项，建议选择版本较低的浏览器，例如：</p>\n<pre class=\"highlight\"><code class=\"plain\">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36\n</code></pre>\n</li>\n<li>\n<p>Upgrade-Insecure-Requests 字段，一些时候存在，一般写死即可：</p>\n<pre class=\"highlight\"><code class=\"plain\">Upgrade-Insecure-Requests: 1\n</code></pre>\n</li>\n<li>\n<p>sec 系列字段，比较新的浏览器普遍存在（这就是为啥 UA 建议选版本较低的浏览器），例如：</p>\n<pre class=\"highlight\"><code class=\"plain\">Sec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: none\nSec-Fetch-User: ?1\nSec-GPC: 1\n</code></pre>\n</li>\n</ul>\n<p>至于这个年头还有没有老版本浏览器嘛，不妨下个 360 危险浏览器看看，建议放在虚拟机里面哦。</p>\n</li>\n</ul>\n<h3 id=\"基于操作特征\"><a class=\"markdownIt-Anchor\" href=\"#基于操作特征\"></a> 基于操作特征</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>正常用户在操作时，操作开始时间、操作持续时间、操作间隔、地理位置信息（一些服务涉及）等具有相当的随机性，而脚本的开发者可能不会注意这些细节，相关参数直接采用固定值，因而操作开始时间、操作持续时间、操作间隔、地理位置信息等长期不变的大概率就是脚本。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>模拟操作开始时间、操作持续时间、操作间隔、地理位置信息等随机化（伪随机即可）。</p>\n</li>\n</ul>\n<h2 id=\"主动检测\"><a class=\"markdownIt-Anchor\" href=\"#主动检测\"></a> 主动检测</h2>\n<h3 id=\"暗改-url\"><a class=\"markdownIt-Anchor\" href=\"#暗改-url\"></a> 暗改 URL</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>对于前后端分离项目，换个域名部署后端再改一下前端 API 公共路径；对于前后端不分离项目，换个域名部署再把原域名 302 过去。正常用户可以捕捉到这个变化，但脚本往往写死了请求的域名，因而还是会使用原域名，请求原域名的大概率就是脚本。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>请求首页及静态资源，对于首页和关键静态资源（JS）进行哈希并与预先准备好的哈希值比对，在发现差异后人工检查。</p>\n</li>\n</ul>\n<h3 id=\"暗改-api\"><a class=\"markdownIt-Anchor\" href=\"#暗改-api\"></a> 暗改 API</h3>\n<ul>\n<li>\n<p>检测原理</p>\n<p>更换某个或某几个常用的 API，并保持被更换的旧 API 有效。正常用户可以捕捉到这个变化，但脚本往往写死了请求的 API，因而还是会使用旧 API，请求旧 API 的大概率就是脚本。</p>\n</li>\n<li>\n<p>应对措施</p>\n<p>请求首页及静态资源，对于首页和关键静态资源（JS）进行哈希并与预先准备好的哈希值比对，在发现差异后人工检查。</p>\n</li>\n</ul>\n","length":"1.8k","time":"7min","categories":["Web"],"tags":["HTML","Python"]}